# 医院挂号系统 - 自动排班算法实现方案

**项目名称**：校医院挂号系统自动排班功能  
**文档版本**：v1.0  
**编制日期**：2025年10月27日  
**技术栈**：Spring Boot + Vue.js + MySQL

---

## 目录

1. [项目概述](#1-项目概述)
2. [需求分析](#2-需求分析)
3. [算法设计](#3-算法设计)
4. [数据模型](#4-数据模型)
5. [输入输出规范](#5-输入输出规范)
6. [技术实现方案](#6-技术实现方案)
7. [API接口设计](#7-api接口设计)
8. [前端界面设计](#8-前端界面设计)
9. [测试方案](#9-测试方案)
10. [实施计划](#10-实施计划)

---

## 1. 项目概述

### 1.1 背景

当前系统支持手动创建排班和批量导入排班，但对于大型医院或多医生科室，手动排班工作繁琐且容易出现冲突。需要一个智能的自动排班系统，能够根据医生信息、科室需求、时间限制等条件，自动生成合理的排班计划。

### 1.2 目标

- **自动化**：减少人工排班工作量，提高效率
- **智能化**：考虑多种约束条件，生成合理排班
- **优化性**：均衡医生工作量，优化资源利用
- **可控性**：支持自定义规则和预览调整

### 1.3 适用场景

- 月度/周度批量排班生成
- 科室新建初始排班
- 应急情况快速补充排班
- 排班优化和重新调整

---

## 2. 需求分析

### 2.1 功能需求

#### 2.1.1 核心功能
- **FR-1**: 根据时间范围和科室自动生成排班
- **FR-2**: 支持自定义排班规则配置
- **FR-3**: 自动检测和避免排班冲突
- **FR-4**: 自动均衡医生工作量
- **FR-5**: 支持排班结果预览和调整
- **FR-6**: 批量保存生成的排班到数据库

#### 2.1.2 约束管理
- **FR-7**: 检查医生请假记录，避免冲突
- **FR-8**: 检查已有排班，避免重复
- **FR-9**: 遵守诊室容量限制
- **FR-10**: 遵守医生状态限制（仅active医生）

#### 2.1.3 数据分析
- **FR-11**: 展示排班覆盖率统计
- **FR-12**: 展示医生工作量分布
- **FR-13**: 列出未能分配的时间段
- **FR-14**: 显示冲突详情和建议

### 2.2 非功能需求

- **NFR-1**: 性能要求：30天 × 10医生 × 8时段，生成时间 < 5秒
- **NFR-2**: 可靠性：排班生成成功率 > 95%
- **NFR-3**: 可用性：界面操作简单，3步完成排班
- **NFR-4**: 扩展性：支持自定义算法策略

---

## 3. 算法设计

### 3.1 算法选择

#### 3.1.1 核心算法：约束满足问题（CSP）+ 贪心策略

**选择理由**：
- 排班问题本质是带多重约束的组合优化问题
- CSP能有效处理硬约束（必须满足）和软约束（尽量满足）
- 贪心策略能在合理时间内找到可行解
- 实现复杂度适中，适合中小规模医院

#### 3.1.2 算法对比

| 算法 | 优点 | 缺点 | 适用场景 | 本项目适用性 |
|------|------|------|----------|------------|
| **CSP+贪心** | 实现简单、速度快、易理解 | 非全局最优 | 中小规模 | ⭐⭐⭐⭐⭐ 推荐 |
| 遗传算法 | 全局优化、灵活 | 实现复杂、调参困难 | 大规模复杂约束 | ⭐⭐⭐ 备选 |
| 模拟退火 | 避免局部最优 | 收敛慢 | 优化问题 | ⭐⭐ 不推荐 |
| 整数规划 | 最优解 | 计算量大 | 小规模 | ⭐⭐ 过度设计 |
| 回溯搜索 | 完整搜索 | 指数复杂度 | 小规模精确解 | ⭐⭐ 性能问题 |

### 3.2 算法流程

```
┌─────────────────────────────────────────────────────────────┐
│                    自动排班算法流程                          │
└─────────────────────────────────────────────────────────────┘

输入: 科室ID, 开始日期, 结束日期, 排班规则
    ↓
┌──────────────────────────────┐
│  1. 数据准备阶段              │
│  - 获取科室所有active医生     │
│  - 获取时间段列表             │
│  - 获取可用诊室列表           │
│  - 加载已有排班               │
│  - 加载请假记录               │
└──────────────────────────────┘
    ↓
┌──────────────────────────────┐
│  2. 约束预处理阶段            │
│  - 构建医生可用性矩阵         │
│  - 标记请假时间段             │
│  - 计算初始工作量             │
│  - 验证基本可行性             │
└──────────────────────────────┘
    ↓
┌──────────────────────────────┐
│  3. 排班生成阶段（核心）      │
│  FOR 每一天 date:             │
│    FOR 每个时间段 slot:       │
│      ┌─────────────────────┐ │
│      │ 3.1 筛选可用医生    │ │
│      │  - 无时间冲突       │ │
│      │  - 不在请假         │ │
│      │  - 有可用诊室       │ │
│      │  - 未超工作量限制   │ │
│      └─────────────────────┘ │
│      ↓                        │
│      ┌─────────────────────┐ │
│      │ 3.2 医生排序        │ │
│      │  - 按当前工作量升序 │ │
│      │  - 优先分配工作少者 │ │
│      └─────────────────────┘ │
│      ↓                        │
│      ┌─────────────────────┐ │
│      │ 3.3 分配医生        │ │
│      │  - 选择工作量最少   │ │
│      │  - 分配诊室         │ │
│      │  - 创建排班记录     │ │
│      │  - 更新工作量计数   │ │
│      └─────────────────────┘ │
└──────────────────────────────┘
    ↓
┌──────────────────────────────┐
│  4. 验证阶段                  │
│  - 检测排班冲突               │
│  - 验证约束满足情况           │
│  - 计算覆盖率统计             │
│  - 识别未分配时间段           │
└──────────────────────────────┘
    ↓
┌──────────────────────────────┐
│  5. 结果生成                  │
│  - 构建排班结果列表           │
│  - 生成工作量分布报告         │
│  - 生成统计数据               │
│  - 返回完整结果对象           │
└──────────────────────────────┘
    ↓
输出: 排班列表, 统计信息, 冲突列表
```

### 3.3 约束系统设计

#### 3.3.1 硬约束（Hard Constraints）- 必须满足

| 约束ID | 约束名称 | 描述 | 检查逻辑 | 违反后果 |
|--------|----------|------|----------|----------|
| HC-1 | 时空唯一性 | 同一医生不能在同一时间出现在多个地方 | 检查(doctor_id, date, slot_id)唯一性 | 拒绝分配 |
| HC-2 | 请假约束 | 请假期间不能排班 | 查询leave_requests表 | 跳过该医生 |
| HC-3 | 医生状态 | 仅active状态医生可排班 | doctors.status='active' | 过滤医生 |
| HC-4 | 诊室容量 | 不超过诊室同时容纳人数 | locations.capacity | 选择其他诊室 |
| HC-5 | 科室匹配 | 医生只能在所属科室排班 | doctors.department_id | 过滤医生 |

#### 3.3.2 软约束（Soft Constraints）- 尽量满足

| 约束ID | 约束名称 | 描述 | 优化目标 | 权重 |
|--------|----------|------|----------|------|
| SC-1 | 工作量均衡 | 各医生工作量应尽量相近 | minimize(max_workload - min_workload) | 高 |
| SC-2 | 连续工作限制 | 避免连续工作超过N天 | 每N天至少休息1天 | 中 |
| SC-3 | 休息间隔 | 两次班次间保证休息时间 | 间隔 >= 配置值 | 中 |
| SC-4 | 时间偏好 | 尽量满足医生时间偏好 | 匹配preferredTimeSlots | 低 |
| SC-5 | 最少值班数 | 每个时段保证最少医生数 | >= minDoctorsPerSlot | 高 |

### 3.4 算法伪代码

```java
Algorithm: AutoScheduleGeneration
Input: 
    departmentId: 科室ID
    startDate, endDate: 时间范围
    rules: 排班规则对象
Output: 
    schedules: 排班列表
    statistics: 统计信息
    conflicts: 冲突列表

BEGIN
    // ========== 阶段1: 初始化 ==========
    doctors ← getActiveDoctorsByDepartment(departmentId)
    timeSlots ← getAllTimeSlots()
    locations ← getLocationsByDepartment(departmentId)
    existingSchedules ← getExistingSchedules(startDate, endDate)
    leaveRequests ← getApprovedLeaveRequests(startDate, endDate)
    
    schedules ← []
    workloadMap ← initializeWorkload(doctors)  // 每个医生工作量初始为0
    unassignedSlots ← []
    
    // ========== 阶段2: 主循环 ==========
    FOR each date IN [startDate, endDate] DO
        FOR each slot IN timeSlots DO
            
            // 2.1 筛选可用医生
            availableDoctors ← []
            FOR each doctor IN doctors DO
                IF checkHardConstraints(doctor, date, slot) THEN
                    availableDoctors.add(doctor)
                END IF
            END FOR
            
            // 2.2 如果没有可用医生，记录未分配
            IF availableDoctors.isEmpty() THEN
                unassignedSlots.add({date, slot, reason: "无可用医生"})
                CONTINUE
            END IF
            
            // 2.3 按工作量排序（贪心策略核心）
            sortByWorkload(availableDoctors, workloadMap)  // 升序
            
            // 2.4 选择工作量最少的医生
            selectedDoctor ← availableDoctors[0]
            
            // 2.5 分配诊室
            assignedLocation ← selectLocation(selectedDoctor, locations, date, slot)
            IF assignedLocation IS NULL THEN
                unassignedSlots.add({date, slot, reason: "无可用诊室"})
                CONTINUE
            END IF
            
            // 2.6 创建排班记录
            schedule ← createSchedule(
                doctor: selectedDoctor,
                date: date,
                slot: slot,
                location: assignedLocation,
                totalSlots: rules.defaultTotalSlots,
                fee: calculateFee(selectedDoctor, rules),
                status: "available"
            )
            
            schedules.add(schedule)
            
            // 2.7 更新工作量
            workloadMap[selectedDoctor.id] ← workloadMap[selectedDoctor.id] + 1
            
        END FOR
    END FOR
    
    // ========== 阶段3: 后处理 ==========
    // 3.1 冲突检测
    conflicts ← detectConflicts(schedules, existingSchedules)
    
    // 3.2 软约束检查
    violations ← checkSoftConstraints(schedules, rules)
    
    // 3.3 生成统计
    statistics ← generateStatistics(schedules, workloadMap, unassignedSlots)
    
    // ========== 返回结果 ==========
    RETURN {
        success: conflicts.isEmpty(),
        schedules: schedules,
        statistics: statistics,
        conflicts: conflicts,
        unassignedSlots: unassignedSlots,
        softConstraintViolations: violations
    }
END

// ========== 辅助函数 ==========

Function checkHardConstraints(doctor, date, slot) -> Boolean
BEGIN
    // HC-1: 时空唯一性检查
    IF hasExistingSchedule(doctor, date, slot) THEN
        RETURN FALSE
    END IF
    
    // HC-2: 请假检查
    IF isOnLeave(doctor, date) THEN
        RETURN FALSE
    END IF
    
    // HC-3: 医生状态检查
    IF doctor.status ≠ "active" THEN
        RETURN FALSE
    END IF
    
    // HC-4: 工作量上限检查（可选）
    IF workloadMap[doctor.id] >= rules.maxShiftsPerDoctor THEN
        RETURN FALSE
    END IF
    
    RETURN TRUE
END

Function sortByWorkload(doctors, workloadMap)
BEGIN
    // 按当前工作量升序排序
    sort(doctors, key: λd → workloadMap[d.id])
END

Function selectLocation(doctor, locations, date, slot) -> Location
BEGIN
    FOR each location IN locations DO
        // 检查诊室是否可用
        IF isLocationAvailable(location, date, slot) THEN
            RETURN location
        END IF
    END FOR
    RETURN NULL
END

Function detectConflicts(schedules, existingSchedules) -> List<Conflict>
BEGIN
    conflicts ← []
    allSchedules ← schedules + existingSchedules
    
    // 检查时空冲突
    FOR each s1 IN allSchedules DO
        FOR each s2 IN allSchedules WHERE s2 ≠ s1 DO
            IF s1.doctorId = s2.doctorId 
               AND s1.date = s2.date 
               AND s1.slotId = s2.slotId THEN
                conflicts.add({type: "TIME_CONFLICT", schedule1: s1, schedule2: s2})
            END IF
        END FOR
    END FOR
    
    RETURN conflicts
END
```

### 3.5 时间复杂度分析

**主循环复杂度**：
- 外层循环（日期）：O(D)，D为天数
- 中层循环（时间段）：O(S)，S为每天时间段数
- 内层医生筛选：O(N)，N为医生数量
- 医生排序：O(N log N)

**总时间复杂度**：O(D × S × N log N)

**实际案例分析**：
- 30天排班，8个时间段，10个医生
- 操作次数：30 × 8 × 10 × log(10) ≈ 7,968 次
- 预计执行时间：< 1秒

**优化策略**：
- 使用缓存减少数据库查询
- 预计算医生可用性矩阵
- 使用位图加速冲突检测

### 3.6 空间复杂度分析

**主要数据结构**：
- 医生列表：O(N)
- 排班结果：O(D × S)
- 工作量映射：O(N)
- 已有排班索引：O(D × S × N)

**总空间复杂度**：O(D × S × N)

**实际案例**：
- 30天 × 8时段 × 10医生 × 200字节 ≈ 480 KB
- 内存占用极小，无压力

---

## 4. 数据模型

### 4.1 数据库表结构（已存在）

#### 4.1.1 schedules（排班表）- 核心表

```sql
CREATE TABLE schedules (
    schedule_id INT PRIMARY KEY AUTO_INCREMENT,
    doctor_id INT NOT NULL,                    -- 外键: doctors
    schedule_date DATE NOT NULL,               -- 排班日期
    slot_id INT NOT NULL,                      -- 外键: time_slots
    location_id INT NOT NULL,                  -- 外键: locations
    total_slots INT NOT NULL,                  -- 号源数量
    booked_slots INT DEFAULT 0,                -- 已预约数
    fee DECIMAL(10,2) NOT NULL,                -- 挂号费
    status ENUM('available','full','cancelled'),
    remarks TEXT,                              -- 备注
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY unique_schedule (doctor_id, schedule_date, slot_id)
);
```

#### 4.1.2 doctors（医生表）

```sql
CREATE TABLE doctors (
    doctor_id INT PRIMARY KEY AUTO_INCREMENT,
    department_id INT NOT NULL,
    identifier VARCHAR(100) UNIQUE,
    full_name VARCHAR(100),
    title VARCHAR(100),
    status ENUM('active','inactive','locked'),
    -- ... 其他字段
);
```

#### 4.1.3 time_slots（时间段表）

```sql
CREATE TABLE time_slots (
    slot_id INT PRIMARY KEY AUTO_INCREMENT,
    slot_name VARCHAR(100),
    start_time TIME,
    end_time TIME
);
```

#### 4.1.4 locations（诊室表）

```sql
CREATE TABLE locations (
    location_id INT PRIMARY KEY AUTO_INCREMENT,
    location_name VARCHAR(100),
    department_id INT,
    building VARCHAR(50),
    floor_level INT,
    room_number VARCHAR(20),
    capacity INT,                              -- 容纳人数
    -- ...
);
```

#### 4.1.5 leave_requests（请假表）

```sql
CREATE TABLE leave_requests (
    request_id INT PRIMARY KEY AUTO_INCREMENT,
    doctor_id INT NOT NULL,
    request_type ENUM('leave','schedule_change'),
    start_time DATETIME,
    end_time DATETIME,
    status ENUM('pending','approved','rejected'),
    -- ...
);
```

### 4.2 Java实体类映射

#### 4.2.1 Schedule（排班实体）

```java
@Entity
@Table(name = "schedules")
public class Schedule {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer scheduleId;
    
    @ManyToOne
    @JoinColumn(name = "doctor_id")
    private Doctor doctor;
    
    @Column(name = "schedule_date")
    private LocalDate scheduleDate;
    
    @ManyToOne
    @JoinColumn(name = "slot_id")
    private TimeSlot slot;
    
    @ManyToOne
    @JoinColumn(name = "location_id")
    private Location location;
    
    private Integer totalSlots;
    private Integer bookedSlots;
    private BigDecimal fee;
    
    @Enumerated(EnumType.STRING)
    private ScheduleStatus status;
    
    private String remarks;
    // ... getters/setters
}
```

### 4.3 DTO类设计

#### 4.3.1 AutoScheduleRequest（请求参数）

```java
@Data
public class AutoScheduleRequest {
    @NotNull(message = "科室ID不能为空")
    private Integer departmentId;
    
    @NotNull(message = "开始日期不能为空")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate startDate;
    
    @NotNull(message = "结束日期不能为空")
    @JsonFormat(pattern = "yyyy-MM-dd")
    private LocalDate endDate;
    
    /**
     * 排班规则配置
     */
    private ScheduleRules rules;
    
    /**
     * 是否覆盖已有排班（默认false，不覆盖）
     */
    private Boolean overwriteExisting = false;
    
    /**
     * 是否仅预览（不保存到数据库）
     */
    private Boolean previewOnly = false;
}
```

#### 4.3.2 ScheduleRules（排班规则）

```java
@Data
public class ScheduleRules {
    /**
     * 每个时段最少医生数（软约束）
     */
    private Integer minDoctorsPerSlot = 1;
    
    /**
     * 每个时段最多医生数（软约束）
     */
    private Integer maxDoctorsPerSlot = 3;
    
    /**
     * 每位医生最大班次数（整个周期）
     */
    private Integer maxShiftsPerDoctor = 999;
    
    /**
     * 默认号源数量
     */
    private Integer defaultTotalSlots = 20;
    
    /**
     * 默认挂号费
     */
    private BigDecimal defaultFee = new BigDecimal("5.00");
    
    /**
     * 连续工作天数限制
     */
    private Integer consecutiveWorkDaysLimit = 6;
    
    /**
     * 最少休息天数
     */
    private Integer minRestDays = 1;
    
    /**
     * 是否启用工作量均衡
     */
    private Boolean balanceWorkload = true;
    
    /**
     * 是否考虑医生时间偏好（预留，后续实现）
     */
    private Boolean considerPreferences = false;
}
```

#### 4.3.3 AutoScheduleResponse（响应结果）

```java
@Data
public class AutoScheduleResponse {
    /**
     * 是否成功
     */
    private Boolean success;
    
    /**
     * 提示消息
     */
    private String message;
    
    /**
     * 生成的排班列表
     */
    private List<ScheduleResponse> schedules;
    
    /**
     * 统计信息
     */
    private ScheduleStatistics statistics;
    
    /**
     * 冲突列表
     */
    private List<ScheduleConflict> conflicts;
    
    /**
     * 未分配的时间段
     */
    private List<UnassignedSlot> unassignedSlots;
    
    /**
     * 工作量分布
     */
    private Map<Integer, DoctorWorkload> workloadDistribution;
    
    /**
     * 软约束违反情况
     */
    private List<String> warnings;
}
```

#### 4.3.4 ScheduleStatistics（统计信息）

```java
@Data
public class ScheduleStatistics {
    /**
     * 总排班数
     */
    private Integer totalSchedules;
    
    /**
     * 覆盖天数
     */
    private Integer coveredDays;
    
    /**
     * 参与医生数
     */
    private Integer doctorsInvolved;
    
    /**
     * 平均工作量（每位医生平均班次）
     */
    private Double averageWorkload;
    
    /**
     * 最大工作量
     */
    private Integer maxWorkload;
    
    /**
     * 最小工作量
     */
    private Integer minWorkload;
    
    /**
     * 排班覆盖率（实际分配数/总需求数）
     */
    private Double coverageRate;
    
    /**
     * 冲突数量
     */
    private Integer conflictCount;
    
    /**
     * 生成耗时（毫秒）
     */
    private Long executionTime;
}
```

#### 4.3.5 DoctorWorkload（医生工作量）

```java
@Data
public class DoctorWorkload {
    private Integer doctorId;
    private String doctorName;
    private String title;
    
    /**
     * 总班次数
     */
    private Integer totalShifts;
    
    /**
     * 工作天数
     */
    private Integer workDays;
    
    /**
     * 最长连续工作天数
     */
    private Integer maxConsecutiveDays;
    
    /**
     * 排班详情（日期->时段列表）
     */
    private Map<LocalDate, List<String>> scheduleDetails;
}
```

#### 4.3.6 ScheduleConflict（排班冲突）

```java
@Data
public class ScheduleConflict {
    /**
     * 冲突类型
     */
    private ConflictType type;
    
    /**
     * 冲突描述
     */
    private String description;
    
    /**
     * 涉及的排班ID列表
     */
    private List<Integer> scheduleIds;
    
    /**
     * 涉及的医生
     */
    private String doctorName;
    
    /**
     * 冲突日期
     */
    private LocalDate conflictDate;
    
    /**
     * 冲突时间段
     */
    private String timeSlot;
    
    /**
     * 建议解决方案
     */
    private String suggestion;
}

public enum ConflictType {
    TIME_CONFLICT,          // 时间冲突
    LEAVE_CONFLICT,         // 与请假冲突
    DUPLICATE_SCHEDULE,     // 重复排班
    LOCATION_CONFLICT,      // 诊室冲突
    WORKLOAD_EXCEEDED       // 工作量超限
}
```

#### 4.3.7 UnassignedSlot（未分配时间段）

```java
@Data
public class UnassignedSlot {
    private LocalDate date;
    private Integer slotId;
    private String slotName;
    private String reason;  // 未分配原因
    
    /**
     * 可能的解决方案
     */
    private List<String> suggestions;
}
```

---

## 5. 输入输出规范（基于现有系统架构）

### 5.1 输入规范

#### 5.1.1 HTTP请求格式

**接口地址**：`POST /api/schedules/auto-generate`

**请求头**：
```
Content-Type: application/json
```

**请求体示例1：最简配置**
```json
{
  "departmentId": 2,
  "startDate": "2025-11-01",
  "endDate": "2025-11-30"
}
```

**请求体示例2：完整配置**
```json
{
  "departmentId": 2,
  "startDate": "2025-11-01",
  "endDate": "2025-11-30",
  "overwriteExisting": false,
  "previewOnly": false,
  "rules": {
    "minDoctorsPerSlot": 1,
    "maxDoctorsPerSlot": 3,
    "maxShiftsPerDoctor": 999,
    "defaultTotalSlots": 20,
    "defaultFee": 5.00,
    "consecutiveWorkDaysLimit": 6,
    "minRestDays": 1,
    "balanceWorkload": true,
    "considerPreferences": false
  }
}
```

#### 5.1.2 关键输入参数说明

基于现有手动排班系统架构：
- **departmentId**: 子科室ID（对应`departments`表），与现有ScheduleDashboard选择的科室ID一致
- **startDate/endDate**: 日期格式为`YYYY-MM-DD`字符串，与现有系统日期格式兼容
- **time_slots**: 当前数据库为4个时间段（与手动排班使用相同）：
  - slot_id=1: 上午 08:00-12:00
  - slot_id=2: 上午 08:30-12:00
  - slot_id=3: 下午 14:00-18:00
  - slot_id=4: 下午 14:30-18:00

#### 5.1.2 参数校验规则

| 参数 | 类型 | 必填 | 校验规则 | 默认值 |
|------|------|------|----------|--------|
| departmentId | Integer | 是 | > 0, 科室必须存在 | - |
| startDate | String | 是 | yyyy-MM-dd, 不早于今天 | - |
| endDate | String | 是 | yyyy-MM-dd, >= startDate, 时间跨度<=90天 | - |
| overwriteExisting | Boolean | 否 | true/false | false |
| previewOnly | Boolean | 否 | true/false | false |
| rules.* | 各类型 | 否 | 见ScheduleRules定义 | 见上文 |

### 5.2 输出规范

#### 5.2.1 成功响应示例（完全兼容现有ScheduleResponse结构）

**HTTP状态码**：`200 OK`

```json
{
  "success": true,
  "message": "自动排班生成成功，共生成240条排班记录",
  "schedules": [
    {
      "scheduleId": 1234,
      "doctorId": 3,
      "doctorName": "张建国",
      "doctorTitle": "主任医师",
      "departmentId": 2,
      "departmentName": "心血管内科",
      "scheduleDate": "2025-11-01",
      "slotId": 1,
      "slotName": "上午 08:00-12:00",
      "startTime": "08:00:00",
      "endTime": "12:00:00",
      "locationId": 1,
      "location": "门诊楼201室",
      "totalSlots": 20,
      "bookedSlots": 0,
      "fee": 5.00,
      "status": "available",
      "remarks": "自动排班生成",
      "createdAt": "2025-10-27T10:30:00",
      "updatedAt": "2025-10-27T10:30:00"
    },
    {
      "scheduleId": 1235,
      "doctorId": 102,
      "doctorName": "李医生",
      "scheduleDate": "2025-11-01",
      "slotId": 2,
      "slotName": "上午 08:30-12:00",
      "startTime": "08:30:00",
      "endTime": "12:00:00",
      "locationId": 2,
      "location": "门诊楼202室",
      "totalSlots": 20,
      "bookedSlots": 0,
      "fee": 5.00,
      "status": "available",
      "remarks": "自动排班生成"
    }
  ],
  "statistics": {
    "totalSchedules": 240,
    "coveredDays": 30,
    "doctorsInvolved": 8,
    "averageWorkload": 30.0,
    "maxWorkload": 32,
    "minWorkload": 28,
    "coverageRate": 0.95,
    "conflictCount": 0,
    "executionTime": 1243
  },
  "conflicts": [],
  "unassignedSlots": [
    {
      "date": "2025-11-15",
      "slotId": 3,
      "slotName": "上午 10:00-11:00",
      "reason": "所有医生此时间段不可用",
      "suggestions": [
        "考虑增加医生数量",
        "调整请假安排"
      ]
    }
  ],
  "workloadDistribution": {
    "101": {
      "doctorId": 101,
      "doctorName": "张医生",
      "title": "主任医师",
      "totalShifts": 30,
      "workDays": 15,
      "maxConsecutiveDays": 5,
      "scheduleDetails": {
        "2025-11-01": ["上午 08:00-09:00", "下午 14:00-15:00"],
        "2025-11-02": ["上午 08:00-09:00"]
      }
    },
    "102": {
      "doctorId": 102,
      "doctorName": "李医生",
      "title": "副主任医师",
      "totalShifts": 28,
      "workDays": 14,
      "maxConsecutiveDays": 4,
      "scheduleDetails": {}
    }
  },
  "warnings": [
    "医生101连续工作5天，接近上限",
    "2025-11-15有1个时段未分配"
  ]
}
```

#### 5.2.2 失败响应示例

**HTTP状态码**：`200 OK`（业务失败）

```json
{
  "success": false,
  "message": "无法生成满足所有约束的排班",
  "schedules": [],
  "statistics": null,
  "conflicts": [],
  "unassignedSlots": [],
  "workloadDistribution": {},
  "warnings": [],
  "errors": [
    {
      "type": "INSUFFICIENT_DOCTORS",
      "message": "科室医生数量不足",
      "details": {
        "requiredDoctors": 10,
        "availableDoctors": 3,
        "suggestion": "建议增加医生或减少排班时段"
      }
    }
  ]
}
```

#### 5.2.3 参数错误响应

**HTTP状态码**：`400 Bad Request`

```json
{
  "timestamp": "2025-10-27T10:30:00",
  "status": 400,
  "error": "Bad Request",
  "message": "参数校验失败",
  "errors": [
    {
      "field": "departmentId",
      "message": "科室ID不能为空"
    },
    {
      "field": "startDate",
      "message": "开始日期不能早于今天"
    }
  ],
  "path": "/api/schedules/auto-generate"
}
```

---

## 6. 技术实现方案

### 6.1 后端架构

#### 6.1.1 项目结构

```
springboot/src/main/java/com/example/springboot/
├── controller/
│   └── ScheduleController.java          [修改] 添加自动排班端点
│
├── service/
│   ├── AutoScheduleService.java         [新建] 服务接口
│   └── impl/
│       └── AutoScheduleServiceImpl.java [新建] 服务实现
│
├── dto/
│   ├── AutoScheduleRequest.java         [新建]
│   ├── AutoScheduleResponse.java        [新建]
│   ├── ScheduleRules.java               [新建]
│   ├── DoctorWorkload.java              [新建]
│   ├── ScheduleConflict.java            [新建]
│   ├── UnassignedSlot.java              [新建]
│   └── ScheduleStatistics.java          [新建]
│
├── util/
│   ├── ScheduleConstraintValidator.java [新建] 约束验证器
│   ├── WorkloadCalculator.java          [新建] 工作量计算器
│   └── ConflictDetector.java            [新建] 冲突检测器
│
└── entity/
    ├── Schedule.java                     [已存在]
    ├── Doctor.java                       [已存在]
    ├── TimeSlot.java                     [已存在]
    └── Location.java                     [已存在]
```

#### 6.1.2 核心类实现概要

**AutoScheduleServiceImpl.java（核心服务实现）**

```java
@Service
public class AutoScheduleServiceImpl implements AutoScheduleService {
    
    @Autowired
    private DoctorRepository doctorRepository;
    
    @Autowired
    private TimeSlotRepository timeSlotRepository;
    
    @Autowired
    private LocationRepository locationRepository;
    
    @Autowired
    private ScheduleRepository scheduleRepository;
    
    @Autowired
    private LeaveRequestRepository leaveRequestRepository;
    
    @Autowired
    private ScheduleConstraintValidator constraintValidator;
    
    @Autowired
    private WorkloadCalculator workloadCalculator;
    
    @Autowired
    private ConflictDetector conflictDetector;
    
    @Override
    @Transactional
    public AutoScheduleResponse autoGenerateSchedule(AutoScheduleRequest request) {
        long startTime = System.currentTimeMillis();
        
        try {
            // 1. 参数校验
            validateRequest(request);
            
            // 2. 数据准备
            List<Doctor> doctors = prepareActiveDoctors(request.getDepartmentId());
            List<TimeSlot> timeSlots = timeSlotRepository.findAll();
            List<Location> locations = prepareLocations(request.getDepartmentId());
            List<Schedule> existingSchedules = loadExistingSchedules(request);
            Map<Integer, List<LeaveRequest>> leaveMap = buildLeaveRequestMap(
                doctors, request.getStartDate(), request.getEndDate()
            );
            
            // 3. 初始化
            List<Schedule> generatedSchedules = new ArrayList<>();
            Map<Integer, Integer> workloadMap = new HashMap<>();
            List<UnassignedSlot> unassignedSlots = new ArrayList<>();
            
            // 4. 主算法循环
            LocalDate currentDate = request.getStartDate();
            while (!currentDate.isAfter(request.getEndDate())) {
                for (TimeSlot slot : timeSlots) {
                    // 筛选可用医生
                    List<Doctor> availableDoctors = filterAvailableDoctors(
                        doctors, currentDate, slot, workloadMap, 
                        leaveMap, existingSchedules, request.getRules()
                    );
                    
                    if (availableDoctors.isEmpty()) {
                        unassignedSlots.add(createUnassignedSlot(
                            currentDate, slot, "无可用医生"
                        ));
                        continue;
                    }
                    
                    // 按工作量排序
                    sortByWorkload(availableDoctors, workloadMap);
                    
                    // 选择医生并分配
                    Doctor selectedDoctor = availableDoctors.get(0);
                    Location assignedLocation = selectLocation(
                        locations, currentDate, slot, generatedSchedules
                    );
                    
                    if (assignedLocation == null) {
                        unassignedSlots.add(createUnassignedSlot(
                            currentDate, slot, "无可用诊室"
                        ));
                        continue;
                    }
                    
                    // 创建排班
                    Schedule schedule = buildSchedule(
                        selectedDoctor, currentDate, slot, 
                        assignedLocation, request.getRules()
                    );
                    
                    generatedSchedules.add(schedule);
                    workloadMap.merge(selectedDoctor.getDoctorId(), 1, Integer::sum);
                }
                currentDate = currentDate.plusDays(1);
            }
            
            // 5. 冲突检测
            List<ScheduleConflict> conflicts = conflictDetector.detectConflicts(
                generatedSchedules, existingSchedules
            );
            
            // 6. 保存到数据库（如果不是预览模式且无冲突）
            if (!request.getPreviewOnly() && conflicts.isEmpty()) {
                scheduleRepository.saveAll(generatedSchedules);
            }
            
            // 7. 生成统计和响应
            long executionTime = System.currentTimeMillis() - startTime;
            return buildResponse(
                true, generatedSchedules, workloadMap, 
                conflicts, unassignedSlots, doctors, executionTime
            );
            
        } catch (Exception e) {
            log.error("自动排班生成失败", e);
            return buildErrorResponse(e.getMessage());
        }
    }
    
    // ... 其他辅助方法
}
```

**ScheduleConstraintValidator.java（约束验证器）**

```java
@Component
public class ScheduleConstraintValidator {
    
    /**
     * 检查所有硬约束
     */
    public boolean checkHardConstraints(
            Doctor doctor, 
            LocalDate date, 
            TimeSlot slot,
            Map<Integer, List<LeaveRequest>> leaveMap,
            List<Schedule> existingSchedules,
            Map<Integer, Integer> workloadMap,
            ScheduleRules rules) {
        
        // HC-1: 时空唯一性
        if (hasTimeConflict(doctor, date, slot, existingSchedules)) {
            return false;
        }
        
        // HC-2: 请假约束
        if (isOnLeave(doctor, date, leaveMap)) {
            return false;
        }
        
        // HC-3: 医生状态
        if (!DoctorStatus.ACTIVE.equals(doctor.getStatus())) {
            return false;
        }
        
        // HC-4: 工作量上限
        Integer currentWorkload = workloadMap.getOrDefault(doctor.getDoctorId(), 0);
        if (currentWorkload >= rules.getMaxShiftsPerDoctor()) {
            return false;
        }
        
        return true;
    }
    
    /**
     * 检查时间冲突
     */
    private boolean hasTimeConflict(
            Doctor doctor, 
            LocalDate date, 
            TimeSlot slot,
            List<Schedule> schedules) {
        return schedules.stream()
            .anyMatch(s -> 
                s.getDoctor().getDoctorId().equals(doctor.getDoctorId())
                && s.getScheduleDate().equals(date)
                && s.getSlot().getSlotId().equals(slot.getSlotId())
            );
    }
    
    /**
     * 检查是否在请假
     */
    private boolean isOnLeave(
            Doctor doctor, 
            LocalDate date,
            Map<Integer, List<LeaveRequest>> leaveMap) {
        List<LeaveRequest> leaves = leaveMap.get(doctor.getDoctorId());
        if (leaves == null) return false;
        
        LocalDateTime checkDateTime = date.atStartOfDay();
        return leaves.stream()
            .filter(lr -> LeaveRequestStatus.APPROVED.equals(lr.getStatus()))
            .anyMatch(lr -> 
                !checkDateTime.isBefore(lr.getStartTime()) 
                && !checkDateTime.isAfter(lr.getEndTime())
            );
    }
    
    // ... 其他约束检查方法
}
```

**WorkloadCalculator.java（工作量计算器）**

```java
@Component
public class WorkloadCalculator {
    
    /**
     * 计算医生工作量分布
     */
    public Map<Integer, DoctorWorkload> calculateWorkloadDistribution(
            List<Schedule> schedules,
            List<Doctor> doctors) {
        
        Map<Integer, DoctorWorkload> distribution = new HashMap<>();
        
        // 初始化
        for (Doctor doctor : doctors) {
            DoctorWorkload workload = new DoctorWorkload();
            workload.setDoctorId(doctor.getDoctorId());
            workload.setDoctorName(doctor.getFullName());
            workload.setTitle(doctor.getTitle());
            workload.setTotalShifts(0);
            workload.setWorkDays(0);
            workload.setScheduleDetails(new HashMap<>());
            distribution.put(doctor.getDoctorId(), workload);
        }
        
        // 统计
        Map<Integer, Set<LocalDate>> workDaysMap = new HashMap<>();
        for (Schedule schedule : schedules) {
            Integer doctorId = schedule.getDoctor().getDoctorId();
            DoctorWorkload workload = distribution.get(doctorId);
            
            // 增加班次
            workload.setTotalShifts(workload.getTotalShifts() + 1);
            
            // 记录工作日
            workDaysMap.computeIfAbsent(doctorId, k -> new HashSet<>())
                .add(schedule.getScheduleDate());
            
            // 记录排班详情
            workload.getScheduleDetails()
                .computeIfAbsent(schedule.getScheduleDate(), k -> new ArrayList<>())
                .add(schedule.getSlot().getSlotName());
        }
        
        // 计算工作天数和最长连续工作
        for (Map.Entry<Integer, Set<LocalDate>> entry : workDaysMap.entrySet()) {
            DoctorWorkload workload = distribution.get(entry.getKey());
            workload.setWorkDays(entry.getValue().size());
            workload.setMaxConsecutiveDays(
                calculateMaxConsecutiveDays(entry.getValue())
            );
        }
        
        return distribution;
    }
    
    /**
     * 计算最长连续工作天数
     */
    private Integer calculateMaxConsecutiveDays(Set<LocalDate> workDays) {
        if (workDays.isEmpty()) return 0;
        
        List<LocalDate> sortedDays = new ArrayList<>(workDays);
        Collections.sort(sortedDays);
        
        int maxConsecutive = 1;
        int currentConsecutive = 1;
        
        for (int i = 1; i < sortedDays.size(); i++) {
            LocalDate prev = sortedDays.get(i - 1);
            LocalDate curr = sortedDays.get(i);
            
            if (curr.equals(prev.plusDays(1))) {
                currentConsecutive++;
                maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
            } else {
                currentConsecutive = 1;
            }
        }
        
        return maxConsecutive;
    }
}
```

**ConflictDetector.java（冲突检测器）**

```java
@Component
public class ConflictDetector {
    
    /**
     * 检测排班冲突
     */
    public List<ScheduleConflict> detectConflicts(
            List<Schedule> newSchedules,
            List<Schedule> existingSchedules) {
        
        List<ScheduleConflict> conflicts = new ArrayList<>();
        List<Schedule> allSchedules = new ArrayList<>();
        allSchedules.addAll(newSchedules);
        allSchedules.addAll(existingSchedules);
        
        // 检查时空冲突
        for (int i = 0; i < allSchedules.size(); i++) {
            for (int j = i + 1; j < allSchedules.size(); j++) {
                Schedule s1 = allSchedules.get(i);
                Schedule s2 = allSchedules.get(j);
                
                if (isTimeConflict(s1, s2)) {
                    conflicts.add(buildConflict(
                        ConflictType.TIME_CONFLICT,
                        "医生在同一时间有多个排班",
                        s1, s2
                    ));
                }
            }
        }
        
        return conflicts;
    }
    
    /**
     * 判断两个排班是否时间冲突
     */
    private boolean isTimeConflict(Schedule s1, Schedule s2) {
        return s1.getDoctor().getDoctorId().equals(s2.getDoctor().getDoctorId())
            && s1.getScheduleDate().equals(s2.getScheduleDate())
            && s1.getSlot().getSlotId().equals(s2.getSlot().getSlotId());
    }
    
    private ScheduleConflict buildConflict(
            ConflictType type, 
            String description,
            Schedule s1, 
            Schedule s2) {
        ScheduleConflict conflict = new ScheduleConflict();
        conflict.setType(type);
        conflict.setDescription(description);
        conflict.setDoctorName(s1.getDoctor().getFullName());
        conflict.setConflictDate(s1.getScheduleDate());
        conflict.setTimeSlot(s1.getSlot().getSlotName());
        conflict.setScheduleIds(Arrays.asList(
            s1.getScheduleId(), s2.getScheduleId()
        ));
        conflict.setSuggestion("请检查并删除重复排班");
        return conflict;
    }
}
```

### 6.2 前端实现

#### 6.2.1 API封装

**vue_admin/src/api/schedule.js**（修改）

```javascript
import request from '@/utils/request'

// ... 现有API函数

/**
 * 自动生成排班
 * @param {Object} data - 排班参数
 */
export function autoGenerateSchedule(data) {
  return request({
    url: '/api/schedules/auto-generate',
    method: 'post',
    data
  })
}

/**
 * 预览自动排班（不保存）
 * @param {Object} data - 排班参数
 */
export function previewAutoSchedule(data) {
  return request({
    url: '/api/schedules/auto-generate',
    method: 'post',
    data: {
      ...data,
      previewOnly: true
    }
  })
}

/**
 * 获取默认排班规则
 */
export function getDefaultScheduleRules() {
  return request({
    url: '/api/schedules/auto-generate/rules',
    method: 'get'
  })
}
```

#### 6.2.2 自动排班页面组件

**vue_admin/src/views/scheduling/AutoSchedule.vue**（新建）

```vue
<template>
  <div class="auto-schedule-container">
    <el-card class="form-card">
      <template #header>
        <div class="card-header">
          <span>自动排班配置</span>
          <el-button type="primary" @click="handleReset">重置</el-button>
        </div>
      </template>
      
      <el-form :model="form" :rules="rules" ref="formRef" label-width="140px">
        <!-- 基础配置 -->
        <el-form-item label="选择科室" prop="departmentId">
          <el-select 
            v-model="form.departmentId" 
            placeholder="请选择科室"
            style="width: 100%"
          >
            <el-option
              v-for="dept in departments"
              :key="dept.departmentId"
              :label="dept.name"
              :value="dept.departmentId"
            />
          </el-select>
        </el-form-item>
        
        <el-form-item label="排班时间范围" required>
          <el-col :span="11">
            <el-form-item prop="startDate">
              <el-date-picker
                v-model="form.startDate"
                type="date"
                placeholder="开始日期"
                style="width: 100%"
                :disabled-date="disabledStartDate"
                value-format="YYYY-MM-DD"
              />
            </el-form-item>
          </el-col>
          <el-col :span="2" class="text-center">至</el-col>
          <el-col :span="11">
            <el-form-item prop="endDate">
              <el-date-picker
                v-model="form.endDate"
                type="date"
                placeholder="结束日期"
                style="width: 100%"
                :disabled-date="disabledEndDate"
                value-format="YYYY-MM-DD"
              />
            </el-form-item>
          </el-col>
        </el-form-item>
        
        <!-- 高级规则配置 -->
        <el-divider content-position="left">排班规则</el-divider>
        
        <el-form-item label="每时段医生数">
          <el-col :span="11">
            <el-input-number
              v-model="form.rules.minDoctorsPerSlot"
              :min="1"
              :max="10"
              placeholder="最少"
            />
          </el-col>
          <el-col :span="2" class="text-center">~</el-col>
          <el-col :span="11">
            <el-input-number
              v-model="form.rules.maxDoctorsPerSlot"
              :min="1"
              :max="20"
              placeholder="最多"
            />
          </el-col>
        </el-form-item>
        
        <el-form-item label="默认号源数">
          <el-input-number
            v-model="form.rules.defaultTotalSlots"
            :min="1"
            :max="100"
          />
        </el-form-item>
        
        <el-form-item label="默认挂号费">
          <el-input-number
            v-model="form.rules.defaultFee"
            :min="0"
            :max="1000"
            :precision="2"
            :step="0.5"
          />
          <span class="ml-2">元</span>
        </el-form-item>
        
        <el-form-item label="连续工作限制">
          <el-input-number
            v-model="form.rules.consecutiveWorkDaysLimit"
            :min="1"
            :max="10"
          />
          <span class="ml-2">天</span>
        </el-form-item>
        
        <el-form-item label="工作量均衡">
          <el-switch v-model="form.rules.balanceWorkload" />
        </el-form-item>
        
        <el-form-item label="覆盖已有排班">
          <el-switch v-model="form.overwriteExisting" />
          <span class="ml-2 text-warning">
            注意：开启后会覆盖选定时间范围内的已有排班
          </span>
        </el-form-item>
        
        <!-- 操作按钮 -->
        <el-form-item>
          <el-button 
            type="primary" 
            @click="handlePreview"
            :loading="previewLoading"
          >
            预览排班
          </el-button>
          <el-button 
            type="success" 
            @click="handleGenerate"
            :loading="generateLoading"
          >
            生成并保存
          </el-button>
        </el-form-item>
      </el-form>
    </el-card>
    
    <!-- 结果展示 -->
    <el-card v-if="result" class="result-card">
      <template #header>
        <div class="card-header">
          <span>
            <el-icon v-if="result.success" color="green"><SuccessFilled /></el-icon>
            <el-icon v-else color="red"><CircleCloseFilled /></el-icon>
            排班结果
          </span>
        </div>
      </template>
      
      <!-- 统计概览 -->
      <div class="statistics-section">
        <el-row :gutter="20">
          <el-col :span="6">
            <el-statistic title="总排班数" :value="result.statistics.totalSchedules" />
          </el-col>
          <el-col :span="6">
            <el-statistic title="覆盖天数" :value="result.statistics.coveredDays" />
          </el-col>
          <el-col :span="6">
            <el-statistic 
              title="排班覆盖率" 
              :value="(result.statistics.coverageRate * 100).toFixed(1)" 
              suffix="%"
            />
          </el-col>
          <el-col :span="6">
            <el-statistic title="参与医生" :value="result.statistics.doctorsInvolved" />
          </el-col>
        </el-row>
      </div>
      
      <!-- 工作量分布图表 -->
      <el-divider content-position="left">工作量分布</el-divider>
      <div id="workloadChart" style="height: 300px"></div>
      
      <!-- 冲突列表 -->
      <el-divider v-if="result.conflicts.length > 0" content-position="left">
        冲突列表 ({{ result.conflicts.length }})
      </el-divider>
      <el-table 
        v-if="result.conflicts.length > 0"
        :data="result.conflicts"
        border
      >
        <el-table-column prop="type" label="类型" width="120">
          <template #default="{ row }">
            <el-tag type="danger">{{ row.type }}</el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="doctorName" label="医生" width="100" />
        <el-table-column prop="conflictDate" label="日期" width="120" />
        <el-table-column prop="timeSlot" label="时段" width="150" />
        <el-table-column prop="description" label="描述" />
        <el-table-column prop="suggestion" label="建议" />
      </el-table>
      
      <!-- 未分配时间段 -->
      <el-divider v-if="result.unassignedSlots.length > 0" content-position="left">
        未分配时间段 ({{ result.unassignedSlots.length }})
      </el-divider>
      <el-table 
        v-if="result.unassignedSlots.length > 0"
        :data="result.unassignedSlots"
        border
      >
        <el-table-column prop="date" label="日期" width="120" />
        <el-table-column prop="slotName" label="时段" width="150" />
        <el-table-column prop="reason" label="原因" />
      </el-table>
      
      <!-- 警告信息 -->
      <el-alert
        v-if="result.warnings && result.warnings.length > 0"
        type="warning"
        :closable="false"
        class="mt-4"
      >
        <template #title>
          <div v-for="warning in result.warnings" :key="warning">
            {{ warning }}
          </div>
        </template>
      </el-alert>
    </el-card>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import { SuccessFilled, CircleCloseFilled } from '@element-plus/icons-vue'
import * as echarts from 'echarts'
import { autoGenerateSchedule, previewAutoSchedule } from '@/api/schedule'
import { getDepartments } from '@/api/department'

// 数据定义
const formRef = ref()
const departments = ref([])
const result = ref(null)
const previewLoading = ref(false)
const generateLoading = ref(false)

const form = reactive({
  departmentId: null,
  startDate: '',
  endDate: '',
  overwriteExisting: false,
  rules: {
    minDoctorsPerSlot: 1,
    maxDoctorsPerSlot: 3,
    maxShiftsPerDoctor: 999,
    defaultTotalSlots: 20,
    defaultFee: 5.0,
    consecutiveWorkDaysLimit: 6,
    minRestDays: 1,
    balanceWorkload: true,
    considerPreferences: false
  }
})

const rules = {
  departmentId: [
    { required: true, message: '请选择科室', trigger: 'change' }
  ],
  startDate: [
    { required: true, message: '请选择开始日期', trigger: 'change' }
  ],
  endDate: [
    { required: true, message: '请选择结束日期', trigger: 'change' }
  ]
}

// 日期禁用逻辑
const disabledStartDate = (time) => {
  return time.getTime() < Date.now() - 24 * 60 * 60 * 1000
}

const disabledEndDate = (time) => {
  if (!form.startDate) return false
  const startTime = new Date(form.startDate).getTime()
  const maxTime = startTime + 90 * 24 * 60 * 60 * 1000 // 最多90天
  return time.getTime() < startTime || time.getTime() > maxTime
}

// 加载科室列表
const loadDepartments = async () => {
  try {
    const res = await getDepartments()
    departments.value = res.data
  } catch (error) {
    ElMessage.error('加载科室列表失败')
  }
}

// 预览排班
const handlePreview = async () => {
  try {
    await formRef.value.validate()
    previewLoading.value = true
    
    const res = await previewAutoSchedule(form)
    result.value = res.data
    
    if (res.data.success) {
      ElMessage.success('预览生成成功')
      // 渲染图表
      renderWorkloadChart(res.data.workloadDistribution)
    } else {
      ElMessage.warning(res.data.message)
    }
  } catch (error) {
    if (error !== false) {  // 排除表单验证失败
      ElMessage.error('预览失败：' + error.message)
    }
  } finally {
    previewLoading.value = false
  }
}

// 生成排班
const handleGenerate = async () => {
  try {
    await formRef.value.validate()
    
    await ElMessageBox.confirm(
      '确认生成排班？此操作将直接保存到数据库。',
      '确认',
      { type: 'warning' }
    )
    
    generateLoading.value = true
    const res = await autoGenerateSchedule(form)
    result.value = res.data
    
    if (res.data.success) {
      ElMessage.success(`排班生成成功！共生成${res.data.statistics.totalSchedules}条排班`)
      renderWorkloadChart(res.data.workloadDistribution)
    } else {
      ElMessage.error(res.data.message)
    }
  } catch (error) {
    if (error !== 'cancel' && error !== false) {
      ElMessage.error('生成失败：' + error.message)
    }
  } finally {
    generateLoading.value = false
  }
}

// 渲染工作量分布图表
const renderWorkloadChart = (workloadDistribution) => {
  const chartDom = document.getElementById('workloadChart')
  const chart = echarts.init(chartDom)
  
  const doctors = Object.values(workloadDistribution)
  const option = {
    title: { text: '医生工作量对比' },
    tooltip: {},
    xAxis: {
      type: 'category',
      data: doctors.map(d => d.doctorName)
    },
    yAxis: {
      type: 'value',
      name: '班次数'
    },
    series: [
      {
        name: '工作量',
        type: 'bar',
        data: doctors.map(d => d.totalShifts),
        itemStyle: {
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: '#83bff6' },
            { offset: 1, color: '#188df0' }
          ])
        }
      }
    ]
  }
  
  chart.setOption(option)
}

// 重置表单
const handleReset = () => {
  formRef.value.resetFields()
  result.value = null
}

onMounted(() => {
  loadDepartments()
})
</script>

<style scoped>
.auto-schedule-container {
  padding: 20px;
}

.form-card, .result-card {
  margin-bottom: 20px;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.statistics-section {
  margin-bottom: 30px;
}

.text-center {
  text-align: center;
}

.text-warning {
  color: #E6A23C;
  font-size: 12px;
}

.ml-2 {
  margin-left: 8px;
}

.mt-4 {
  margin-top: 16px;
}
</style>
```

#### 6.2.3 路由配置

**vue_admin/src/router/index.js**（修改）

```javascript
{
  path: '/scheduling',
  name: 'Scheduling',
  children: [
    // ... 现有路由
    {
      path: 'auto-generate',
      name: 'AutoSchedule',
      component: () => import('@/views/scheduling/AutoSchedule.vue'),
      meta: { title: '自动排班', icon: 'Magic' }
    }
  ]
}
```

---

## 7. API接口设计

### 7.1 接口列表

| 序号 | 接口路径 | 方法 | 描述 | 权限 | 集成方式 |
|------|----------|------|------|------|----------|
| 1 | `/api/schedules/auto-generate` | POST | 自动生成排班 | ADMIN | 新增接口 |
| 2 | `/api/schedules/auto-generate/rules` | GET | 获取默认规则 | ADMIN | 新增接口 |

### 7.2 接口详细说明

#### 7.2.1 自动生成排班

**接口地址**：`POST /api/schedules/auto-generate`

**请求示例**：（见第5.1节）

**响应示例**：（见第5.2节）

**Controller实现**：

```java
@RestController
@RequestMapping("/api/schedules")
public class ScheduleController {
    
    @Autowired
    private AutoScheduleService autoScheduleService;
    
    /**
     * 自动生成排班
     */
    @PostMapping("/auto-generate")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<AutoScheduleResponse> autoGenerateSchedule(
            @Valid @RequestBody AutoScheduleRequest request) {
        
        log.info("收到自动排班请求: departmentId={}, startDate={}, endDate={}", 
            request.getDepartmentId(), 
            request.getStartDate(), 
            request.getEndDate()
        );
        
        AutoScheduleResponse response = autoScheduleService.autoGenerateSchedule(request);
        
        return ResponseEntity.ok(response);
    }
    
    /**
     * 获取默认排班规则
     */
    @GetMapping("/auto-generate/rules")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ScheduleRules> getDefaultRules() {
        ScheduleRules rules = new ScheduleRules();
        // 默认值已在类中设置
        return ResponseEntity.ok(rules);
    }
}
```

---

## 8. 前端界面设计（基于现有ScheduleDashboard）

### 8.1 前端显示方式

#### 8.1.1 无缝集成到现有ScheduleDashboard

自动排班功能完全集成到现有的ScheduleDashboard界面中，不需要新建页面：

**1. 在现有界面添加"自动排班"按钮：**
- 在ScheduleDashboard的header区域添加"自动排班"按钮
- 与现有的"自动填充排班数据"按钮并列显示
- 按钮位置：位于视图切换按钮组左侧

**2. 自动排班配置对话框：**
- 点击"自动排班"按钮弹出配置对话框
- 对话框包含：日期范围选择、排班规则配置、覆盖选项
- 预览模式：先预览结果再决定是否保存

**3. 结果显示方式：**
- 生成成功后，新的排班记录自动出现在日历网格中
- 与手动拖拽创建的排班显示效果完全一致
- 医生卡片、诊室信息、时间段信息都按现有格式显示
- 自动排班的备注字段为"自动排班生成"，便于区分

**4. 数据结构完全兼容：**
```javascript
// 自动生成返回的schedules数组可直接用于现有组件，无需转换
// response.data.schedules数组的每个元素都符合现有ScheduleResponse格式
// 可直接赋值给scheduleData.value[departmentId]使用
```

**5. 前端集成调用示例：**
```javascript
// 在ScheduleDashboard.vue中添加自动排班功能
import { autoGenerateSchedule } from '@/api/schedule'

// 自动排班函数
const handleAutoSchedule = async () => {
  // 弹出配置对话框
  const config = await showAutoScheduleDialog()

  try {
    const res = await autoGenerateSchedule({
      departmentId: activeSub.value,
      startDate: config.startDate,
      endDate: config.endDate,
      overwriteExisting: config.overwriteExisting,
      previewOnly: config.previewOnly,
      rules: config.rules
    })

    if (res.data.success) {
      // 刷新当前科室的排班数据
      await loadSchedulesFromBackend()

      ElMessage.success(`自动排班成功！生成${res.data.statistics.totalSchedules}条排班记录`)

      // 显示统计信息
      showAutoScheduleResult(res.data)
    } else {
      ElMessage.warning(res.data.message)
    }
  } catch (error) {
    ElMessage.error('自动排班失败：' + error.message)
  }
}
```

### 8.2 自动排班配置对话框设计

```
┌────────────────────────────────────────────────────────────┐
│  自动排班配置                                       [重置]  │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  选择科室:    [呼吸内科 ▼]                                │
│                                                             │
│  排班时间:    [2025-11-01] 至 [2025-11-30]                │
│                                                             │
│  ━━━━━━━━━━━━━━ 排班规则 ━━━━━━━━━━━━━━                  │
│                                                             │
│  每时段医生数: [1] ~ [3]                                   │
│  默认号源数:   [20]                                        │
│  默认挂号费:   [5.00] 元                                   │
│  连续工作限制: [6] 天                                      │
│  工作量均衡:   [√]                                         │
│  覆盖已有排班: [ ] ⚠️ 注意：开启后会覆盖已有排班          │
│                                                             │
│  [预览排班]  [生成并保存]                                  │
│                                                             │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│  ✅ 排班结果                                               │
├────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │
│  │总排班数 │  │覆盖天数 │  │排班覆盖率│  │参与医生│     │
│  │  240   │  │   30    │  │  95.0% │  │   8     │     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘     │
│                                                             │
│  ━━━━━━━━━━━━━━ 工作量分布 ━━━━━━━━━━━━━━                │
│                                                             │
│         ┌─────────────────────────────┐                    │
│         │  医生工作量对比(柱状图)      │                    │
│         │                             │                    │
│         └─────────────────────────────┘                    │
│                                                             │
│  ━━━━━━━━━━━━━━ 冲突列表 (0) ━━━━━━━━━━━━━━              │
│                                                             │
│  ━━━━━━━━━━━━━ 未分配时间段 (2) ━━━━━━━━━━━━━            │
│                                                             │
│  ┌──────┬──────┬────────────────┬──────────────┐        │
│  │日期  │时段  │原因            │建议          │        │
│  ├──────┼──────┼────────────────┼──────────────┤        │
│  │11-15│上午10│所有医生不可用  │增加医生数量  │        │
│  │11-20│下午14│所有医生不可用  │调整请假安排  │        │
│  └──────┴──────┴────────────────┴──────────────┘        │
│                                                             │
│  ⚠️ 医生101连续工作5天，接近上限                          │
│  ⚠️ 2025-11-15有1个时段未分配                             │
│                                                             │
└────────────────────────────────────────────────────────────┘
```

### 8.3 交互流程

```
用户进入页面
    ↓
选择科室和时间范围
    ↓
[可选] 配置高级规则
    ↓
点击"预览排班"
    ↓
    ├─→ 成功：展示统计和图表
    │       ↓
    │   查看结果，确认无误
    │       ↓
    │   点击"生成并保存"
    │       ↓
    │   二次确认
    │       ↓
    │   保存到数据库
    │       ↓
    │   成功提示
    │
    └─→ 失败：展示错误信息
            ↓
        调整配置重试
```

---

## 9. 测试方案

### 9.1 单元测试

#### 9.1.1 约束验证器测试

```java
@SpringBootTest
class ScheduleConstraintValidatorTest {
    
    @Autowired
    private ScheduleConstraintValidator validator;
    
    @Test
    void testTimeConflictDetection() {
        // 测试时间冲突检测
        Doctor doctor = createTestDoctor();
        LocalDate date = LocalDate.of(2025, 11, 1);
        TimeSlot slot = createTestTimeSlot();
        List<Schedule> existing = createExistingSchedules();
        
        boolean result = validator.checkHardConstraints(
            doctor, date, slot, new HashMap<>(), existing, new HashMap<>(), new ScheduleRules()
        );
        
        assertFalse(result, "应检测到时间冲突");
    }
    
    @Test
    void testLeaveRequestConflict() {
        // 测试请假冲突检测
        // ...
    }
}
```

#### 9.1.2 工作量计算测试

```java
@Test
void testWorkloadCalculation() {
    List<Schedule> schedules = createTestSchedules();
    List<Doctor> doctors = createTestDoctors();
    
    Map<Integer, DoctorWorkload> workload = 
        workloadCalculator.calculateWorkloadDistribution(schedules, doctors);
    
    assertEquals(30, workload.get(101).getTotalShifts());
    assertEquals(15, workload.get(101).getWorkDays());
}
```

### 9.2 集成测试

#### 9.2.1 完整流程测试

```java
@SpringBootTest
@AutoConfigureMockMvc
class AutoScheduleIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    @WithMockUser(roles = "ADMIN")
    void testAutoScheduleGeneration() throws Exception {
        AutoScheduleRequest request = new AutoScheduleRequest();
        request.setDepartmentId(5);
        request.setStartDate(LocalDate.now());
        request.setEndDate(LocalDate.now().plusDays(7));
        request.setPreviewOnly(true);
        
        MvcResult result = mockMvc.perform(
            post("/api/schedules/auto-generate")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request))
        )
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.success").value(true))
        .andExpect(jsonPath("$.schedules").isArray())
        .andReturn();
        
        AutoScheduleResponse response = objectMapper.readValue(
            result.getResponse().getContentAsString(),
            AutoScheduleResponse.class
        );
        
        assertTrue(response.getSuccess());
        assertNotNull(response.getStatistics());
    }
}
```

### 9.3 性能测试

#### 9.3.1 测试用例

| 场景 | 天数 | 医生数 | 时段数 | 预期时间 | 目标 |
|------|------|--------|--------|----------|------|
| 小规模 | 7 | 5 | 8 | < 500ms | ✅ |
| 中规模 | 30 | 10 | 8 | < 3s | ✅ |
| 大规模 | 90 | 20 | 12 | < 10s | ✅ |

#### 9.3.2 性能测试代码

```java
@Test
void performanceTest() {
    long startTime = System.currentTimeMillis();
    
    AutoScheduleRequest request = new AutoScheduleRequest();
    request.setDepartmentId(5);
    request.setStartDate(LocalDate.now());
    request.setEndDate(LocalDate.now().plusDays(30));
    
    AutoScheduleResponse response = autoScheduleService.autoGenerateSchedule(request);
    
    long executionTime = System.currentTimeMillis() - startTime;
    
    assertTrue(executionTime < 3000, 
        String.format("执行时间%dms超过3000ms", executionTime));
    assertTrue(response.getSuccess());
}
```

### 9.4 测试数据准备

```sql
-- 准备测试科室
INSERT INTO departments (department_id, parent_id, name) 
VALUES (999, 1, '测试科室');

-- 准备测试医生
INSERT INTO doctors (doctor_id, department_id, identifier, full_name, status) 
VALUES 
(1001, 999, 'TEST001', '测试医生1', 'active'),
(1002, 999, 'TEST002', '测试医生2', 'active'),
(1003, 999, 'TEST003', '测试医生3', 'active');

-- 准备测试诊室
INSERT INTO locations (location_id, location_name, department_id, capacity) 
VALUES 
(9001, '测试诊室1', 999, 1),
(9002, '测试诊室2', 999, 1);

-- 准备测试时间段（使用现有数据）
```

---

## 10. 实施计划

### 10.1 开发阶段划分

| 阶段 | 任务 | 预计工作量 | 优先级 |
|------|------|-----------|--------|
| **阶段1** | **后端基础架构** | | |
| 1.1 | 创建DTO类（7个文件） | 2小时 | P0 |
| 1.2 | 创建工具类（3个文件） | 3小时 | P0 |
| 1.3 | 实现Service接口和实现类 | 5小时 | P0 |
| 1.4 | 实现Controller端点 | 1小时 | P0 |
| **阶段2** | **核心算法实现** | | |
| 2.1 | 实现约束检查逻辑 | 4小时 | P0 |
| 2.2 | 实现主排班算法 | 6小时 | P0 |
| 2.3 | 实现冲突检测 | 3小时 | P0 |
| 2.4 | 实现工作量计算 | 2小时 | P0 |
| **阶段3** | **前端开发** | | |
| 3.1 | 创建API封装 | 1小时 | P0 |
| 3.2 | 开发自动排班页面 | 6小时 | P0 |
| 3.3 | 集成图表组件 | 2小时 | P1 |
| 3.4 | 添加路由和导航 | 1小时 | P0 |
| **阶段4** | **测试与优化** | | |
| 4.1 | 单元测试编写 | 3小时 | P1 |
| 4.2 | 集成测试 | 2小时 | P1 |
| 4.3 | 性能测试与优化 | 3小时 | P1 |
| 4.4 | Bug修复 | 2小时 | P0 |
| **阶段5** | **文档与部署** | | |
| 5.1 | 代码注释完善 | 1小时 | P1 |
| 5.2 | 用户手册编写 | 2小时 | P2 |
| 5.3 | 部署到测试环境 | 1小时 | P0 |
| **总计** | | **约50小时** | |

### 10.2 里程碑计划

| 里程碑 | 完成标志 | 目标日期 |
|--------|----------|----------|
| M1: 后端开发完成 | 所有API可调用，通过Postman测试 | D+3天 |
| M2: 前端开发完成 | 界面功能完整，可预览和生成 | D+5天 |
| M3: 测试完成 | 通过所有测试用例 | D+7天 |
| M4: 正式发布 | 部署到生产环境 | D+10天 |

### 10.3 风险管理

| 风险 | 可能性 | 影响 | 应对策略 |
|------|--------|------|----------|
| 算法性能不达标 | 中 | 高 | 提前性能测试，准备优化方案 |
| 约束逻辑复杂导致bug | 高 | 中 | 充分单元测试，分阶段实现 |
| 用户需求变更 | 中 | 中 | 预留扩展接口，模块化设计 |
| 数据库性能瓶颈 | 低 | 高 | 添加索引，优化查询 |

### 10.4 质量保证

- **代码审查**：每个模块完成后进行代码审查
- **测试覆盖率**：核心算法类测试覆盖率 > 80%
- **性能基准**：30天排班生成时间 < 3秒
- **用户验收**：与管理员进行UAT测试

---

## 11. 附录

### 11.1 术语表

| 术语 | 英文 | 定义 |
|------|------|------|
| 排班 | Schedule | 医生在特定日期和时间段的出诊安排 |
| 时间段 | Time Slot | 固定的时间区间，如"上午8:00-9:00" |
| 号源 | Appointment Slot | 每个排班可接受的预约数量 |
| 工作量 | Workload | 医生在时间段内的班次数量 |
| 硬约束 | Hard Constraint | 必须满足的约束条件 |
| 软约束 | Soft Constraint | 尽量满足但可违反的约束 |
| CSP | Constraint Satisfaction Problem | 约束满足问题 |

### 11.2 参考资料

1. **算法相关**
   - 《算法导论》- Thomas H. Cormen
   - 论文: "Nurse Rostering Problem" (护士排班问题，与医生排班类似)
   
2. **技术文档**
   - Spring Boot官方文档
   - Vue 3官方文档
   - Element Plus组件库文档

3. **项目相关**
   - 数据库表结构设计文档v4.2.md
   - API集成指南
   - 系统设计图

### 11.3 FAQ

**Q1: 如果所有医生都在请假，会发生什么？**  
A: 系统会将该时间段标记为"未分配"，并在结果中列出，不会强制分配。

**Q2: 是否支持自定义算法策略？**  
A: 当前版本使用固定的贪心策略。后续可扩展策略模式，支持多种算法切换。

**Q3: 生成的排班可以手动调整吗？**  
A: 可以。生成后可通过现有的排班管理功能进行手动修改。

**Q4: 是否支持定时自动排班？**  
A: 当前版本不支持。后续可集成Spring Scheduled任务实现定时排班。

**Q5: 如何处理临时加号？**  
A: 自动排班只设置初始号源数，后续可通过排班管理功能调整号源数量。

### 11.4 更新日志

| 版本 | 日期 | 更新内容 | 作者 |
|------|------|----------|------|
| v1.0 | 2025-10-27 | 初始版本，完成算法设计和技术方案 | AI Assistant |
| v1.1 | 2025-01-27 | 更新数据库时间段为4个，明确输入输出和前端显示方式 | AI Assistant |

---

**文档结束**

---

## 文档说明（v1.1更新）

本文档详细阐述了医院挂号系统自动排班功能的完整实现方案，包括：

✅ **算法设计**：详细的CSP+贪心算法，包含伪代码和复杂度分析  
✅ **数据模型**：完整的DTO设计和数据库映射  
✅ **输入输出**：规范的API接口定义和JSON示例，**与现有ScheduleResponse兼容**  
✅ **技术实现**：后端Service/Controller/Util类的详细实现概要  
✅ **前端界面**：Vue组件设计和交互流程，**与现有ScheduleDashboard无缝集成**  
✅ **测试方案**：单元测试、集成测试、性能测试  
✅ **实施计划**：分阶段开发计划和时间估算  

### v1.1 主要更新内容

1. **数据库时间段更新**：明确当前使用4个时间段（08:00-12:00, 08:30-12:00, 14:00-18:00, 14:30-18:00）
2. **输入输出明确**：补充说明基于现有`ScheduleCreateRequest`和`ScheduleResponse`结构
3. **前端显示说明**：
   - 自动生成排班可在现有`ScheduleDashboard`和`ScheduleFeeManagement`中直接显示
   - 数据格式完全兼容，无需修改现有组件
   - 提供了前端调用示例代码
4. **技术兼容性**：强调与现有系统架构完全兼容，采用扩展而非修改的方式

### 实施建议

**预计代码量**：约1500-2000行（后端1200行 + 前端600行）  
**预计开发周期**：7-10个工作日  
**技术难度**：中等偏上（算法复杂度较高，但与现有系统集成简单）

**集成方式**：
- ✅ 后端：新增接口，不影响现有排班功能
- ✅ 前端：可选独立页面或在现有页面添加"自动排班"按钮
- ✅ 数据：生成的排班与手动排班数据结构一致
- ✅ 兼容：可先预览后保存，确保安全性

该方案基于你现有的数据库结构和技术栈设计，采用扩展方式实现，风险可控，易于维护。

