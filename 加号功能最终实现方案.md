# 加号功能最终实现方案

## 核心设计理念

### 预留机制（Soft Reservation）

**关键原则**：加号号源不占用 `totalSlots`，而是通过"软预留"机制实现专属访问。

## 实现细节

### 1. 批准加号时

```java
// 不修改 totalSlots，只在备注中记录
schedule.setRemarks(schedule.getRemarks() + "; 加号+2(申请ID:123)");

// 创建加号预约（状态：PENDING_PAYMENT）
Appointment appointment = new Appointment();
appointment.setAppointmentType(AppointmentType.ADD_ON);
appointment.setStatus(AppointmentStatus.PENDING_PAYMENT);
appointment.setPaymentDeadline(LocalDateTime.now().plusHours(24));
// 关键：不占用 bookedSlots
```

**结果**：
- `totalSlots`: 10（不变）
- `bookedSlots`: 5（不变）
- 待支付加号数: 2（新增）
- 实际可用号源: 10 - 5 - 2 = 3

### 2. 普通患者预约时

```java
// 检查可用号源（扣除待支付的加号）
Integer actualAvailable = totalSlots - bookedSlots - pendingAddOnCount;
if (actualAvailable <= 0) {
    throw new RuntimeException("号源已满");
}
```

**效果**：加号号源被"软预留"，普通患者无法预约。

### 3. 加号患者支付成功

```java
// 更新预约状态
appointment.setStatus(AppointmentStatus.scheduled);
appointment.setPaymentStatus(PaymentStatus.paid);

// 占用号源
schedule.setBookedSlots(schedule.getBookedSlots() + 1);
```

**结果**：
- `totalSlots`: 10（不变）
- `bookedSlots`: 6（+1）
- 待支付加号数: 1（-1）
- 实际可用号源: 10 - 6 - 1 = 3

### 4. 加号支付超时

```java
// 只需取消预约
appointment.setStatus(AppointmentStatus.cancelled);
// 不修改 totalSlots 和 bookedSlots
```

**结果**：
- `totalSlots`: 10（不变）
- `bookedSlots`: 5（不变）
- 待支付加号数: 0（-1，自动释放）
- 实际可用号源: 10 - 5 - 0 = 5

## 排队问题解决

### 序号分配策略

```java
// 普通预约：1-100
// 加号预约：101-200

Integer nextNumber;
if (appointmentType == AppointmentType.ADD_ON) {
    Integer maxAddOnNumber = appointmentRepository
        .findMaxAppointmentNumberByScheduleAndType(schedule, AppointmentType.ADD_ON);
    nextNumber = (maxAddOnNumber == null || maxAddOnNumber < 101) ? 101 : maxAddOnNumber + 1;
} else {
    Integer maxNormalNumber = appointmentRepository
        .findMaxAppointmentNumberByScheduleAndType(schedule, AppointmentType.NORMAL);
    nextNumber = (maxNormalNumber == null) ? 1 : maxNormalNumber + 1;
}
```

### 叫号顺序

**方案A：按序号排队**
- 普通患者：1, 2, 3, ..., 100
- 加号患者：101, 102, 103, ...
- 叫号时按序号升序排列

**方案B：按类型优先级**
- 可以根据紧急程度调整加号患者的优先级
- 危急加号可以插队到普通患者前面

## 数据库查询

### 关键查询方法

```java
// 1. 查询指定排班和类型的最大序号
Integer findMaxAppointmentNumberByScheduleAndType(Schedule schedule, AppointmentType type);

// 2. 统计待支付加号数量
Integer countByScheduleAndTypeAndStatus(Schedule schedule, AppointmentType type, AppointmentStatus status);

// 3. 查询超时未支付的加号
List<Appointment> findExpiredAddOnPayments(AppointmentType type, AppointmentStatus status, LocalDateTime now);
```

### 可用号源计算

```sql
-- 实际可用号源 = 总号源 - 已预约 - 待支付加号
SELECT 
    s.total_slots - s.booked_slots - COALESCE(pending.count, 0) AS actual_available
FROM schedules s
LEFT JOIN (
    SELECT schedule_id, COUNT(*) as count
    FROM appointments
    WHERE appointment_type = 'ADD_ON' 
      AND status = 'PENDING_PAYMENT'
    GROUP BY schedule_id
) pending ON s.schedule_id = pending.schedule_id
WHERE s.schedule_id = ?;
```

## 优势分析

### ✅ 解决的问题

1. **号源独占性**：
   - 待支付的加号被"软预留"
   - 普通患者无法预约这些号源
   - 加号患者有专属访问权

2. **排队清晰**：
   - 使用独立序号范围（101+）
   - 叫号时可以区分普通号和加号
   - 支持灵活的优先级策略

3. **数据一致性**：
   - 不修改 `totalSlots`，避免数据混乱
   - 支付前不占用 `bookedSlots`
   - 超时自动释放，无需手动调整

4. **避免约束冲突**：
   - 不创建虚拟号源
   - 不违反数据库唯一约束
   - 实现简单清晰

### ⚠️ 注意事项

1. **查询性能**：
   - 每次检查可用号源需要统计待支付加号
   - 建议在 `appointments` 表上添加复合索引：
     ```sql
     CREATE INDEX idx_addon_pending ON appointments(schedule_id, appointment_type, status);
     ```

2. **并发控制**：
   - 使用 `@Transactional` 确保原子性
   - 考虑使用乐观锁或悲观锁

3. **前端显示**：
   - 需要明确区分普通号和加号
   - 显示实际可用号源（扣除待支付加号）

## 完整流程图

```
医生申请加号
    ↓
管理员批准
    ↓
创建加号预约（PENDING_PAYMENT）
    ├─ 不修改 totalSlots
    ├─ 不占用 bookedSlots
    ├─ 设置支付截止时间（24小时）
    └─ 分配序号（101+）
    ↓
号源被"软预留"
    ├─ 普通患者：看到的可用号源 = totalSlots - bookedSlots - 待支付加号
    └─ 加号患者：可以支付并激活预约
    ↓
两种结果：
    ├─ 支付成功 → bookedSlots + 1 → 预约生效
    └─ 支付超时 → 取消预约 → 号源自动释放
```

## 测试场景

### 场景1：基本流程

1. 原始状态：`totalSlots=10, bookedSlots=5`
2. 批准2个加号：待支付加号=2
3. 普通患者查询：可用号源=10-5-2=3 ✅
4. 加号患者支付：`bookedSlots=6`，待支付加号=1
5. 最终状态：`totalSlots=10, bookedSlots=6`，可用=3 ✅

### 场景2：超时释放

1. 原始状态：`totalSlots=10, bookedSlots=5`，待支付加号=2
2. 1个加号超时：待支付加号=1
3. 普通患者查询：可用号源=10-5-1=4 ✅
4. 号源自动释放，无需手动调整 ✅

### 场景3：并发预约

1. 原始状态：`totalSlots=10, bookedSlots=9`，待支付加号=1
2. 普通患者A查询：可用=0，无法预约 ✅
3. 加号患者B支付：成功，`bookedSlots=10` ✅
4. 普通患者C查询：可用=0，无法预约 ✅

## 代码清单

### 新增文件
- `ScheduleAvailabilityService.java`：号源可用性检查服务

### 修改文件
- `AddOnSlotService.java`：加号审批和支付处理
- `AddOnPaymentExpirationTask.java`：超时处理任务
- `AppointmentRepository.java`：新增查询方法

### 数据库索引（建议添加）
```sql
-- 优化待支付加号统计查询
CREATE INDEX idx_addon_pending ON appointments(schedule_id, appointment_type, status);

-- 优化序号查询
CREATE INDEX idx_appointment_number ON appointments(schedule_id, appointment_type, appointment_number);
```

## 总结

这个方案通过**预留机制**实现了加号号源的专属访问，同时：
- ✅ 不修改数据库结构
- ✅ 不违反唯一约束
- ✅ 逻辑清晰简单
- ✅ 数据一致性强
- ✅ 支持灵活的排队策略

是一个**最小化改动、最大化效果**的实现方案。
