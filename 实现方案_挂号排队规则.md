# 医院挂号排队规则实现方案

## 一、当前代码状态评估

### ✅ 已实现的功能

1. **基础字段**：
   - `appointmentType`：预约类型（预约/现场/复诊/加号）
   - `isWalkIn`：是否现场挂号
   - `isAddOn`：是否加号
   - `isPriority`：是否优先号
   - `originalAppointmentId`：原始预约ID（用于复诊关联）
   - `realTimeQueueNumber`：实时候诊序号
   - `isLate`：是否迟到
   - `recheckInTime`：过号后重新签到时间

2. **基础排序逻辑**：
   - 预约优先于现场挂号
   - 按时签到优先于迟到
   - 提前签到按挂号序号，时段内签到按签到时间

### ❌ 需要调整的功能

1. **签到时间窗口**：
   - 当前：软关门5分钟（时段结束后5分钟）
   - 需要：时段开始前15分钟至时段结束前10分钟

2. **过号处理**：
   - 当前：顺延5个患者
   - 需要：重新扫码排当前时段队尾

3. **复诊号插入**：
   - 当前：已有逻辑但需要验证
   - 需要：每两位正常患者后插入一个复诊号

4. **加号功能**：
   - 当前：有字段但缺少创建加号的接口
   - 需要：医生同意后创建加号，排在所有正常号末尾

5. **当日复诊**：
   - 当前：有字段但缺少创建复诊号的接口
   - 需要：分诊台创建复诊号，区分同医生/不同医生

## 二、详细实现方案

### 1. 调整签到时间窗口

**规则**：时段开始前15分钟至时段结束前10分钟

**修改位置**：`AppointmentService.checkIn()` 方法

```java
// 计算签到时间窗口
LocalDateTime checkInStartTime = scheduleStartTime.minusMinutes(15); // 开始前15分钟
LocalDateTime checkInEndTime = scheduleEndTime.minusMinutes(10);     // 结束前10分钟

// 判断是否在签到窗口内
if (now.isBefore(checkInStartTime)) {
    throw new BadRequestException("签到时间未到，请在时段开始前15分钟开始签到");
}

if (now.isAfter(checkInEndTime) && now.isBefore(scheduleEndTime)) {
    // 时段结束前10分钟之后，但未到时段结束：允许签到但标记为迟到，排末尾
    isLate = true;
    logger.warn("迟到签到 - 预约ID: {}, 签到时间: {}, 签到截止时间: {}", 
            appointmentId, now, checkInEndTime);
}

if (now.isAfter(scheduleEndTime)) {
    // 时段已结束：需改约或退号
    throw new BadRequestException("时段已结束，无法签到。请改约后续时段或退号");
}
```

### 2. 修复过号处理逻辑

**规则**：过号后重新扫码，排当前时段队尾

**修改位置**：`AppointmentService.recheckInAfterMissedCall()` 方法

```java
// 当前实现已经是排末尾，但需要确保是"当前时段"的末尾
// 查询当前时段已签到的所有患者，找到最大序号
List<Appointment> currentSlotAppointments = checkedInAppointments.stream()
    .filter(a -> {
        // 判断是否在同一时段（通过schedule判断）
        return a.getSchedule().getScheduleId().equals(schedule.getScheduleId());
    })
    .collect(Collectors.toList());

int maxNumber = currentSlotAppointments.stream()
    .filter(a -> a.getRealTimeQueueNumber() != null && 
               !a.getAppointmentId().equals(currentAppointmentId))
    .mapToInt(Appointment::getRealTimeQueueNumber)
    .max()
    .orElse(0);

appointment.setRealTimeQueueNumber(maxNumber + 1);
```

### 3. 修复复诊号插入逻辑

**规则**：每两位正常患者后插入一个复诊号

**修改位置**：`AppointmentService.getCallQueue()` 方法

```java
// 当前代码已有插入逻辑，但需要验证是否正确
// 第978-988行的逻辑：
// 每两位正常患者后插入一个复诊号（i += 3 表示每3个位置插入一个，即每2个正常患者后1个复诊号）
for (int i = 2; i < finalQueue.size() && followUpIndex < sameDayFollowUps.size(); i += 3) {
    finalQueue.add(i, sameDayFollowUps.get(followUpIndex));
    followUpIndex++;
}
```

**验证**：这个逻辑是正确的，但需要确保：
- 优先号不参与"每两位"的计算
- 复诊号插入后，后续的正常患者序号需要重新计算

### 4. 实现加号功能

**需要新增**：
1. 医生紧急加号接口（医生端）
2. 加号创建逻辑

**实现步骤**：

```java
// 1. 创建加号请求DTO
public class AddOnRequest {
    private Integer patientId;      // 患者ID
    private Integer scheduleId;      // 排班ID
    private String reason;          // 加号原因（可选）
}

// 2. 医生直接创建加号
@Transactional
public AppointmentResponse createAddOn(AddOnRequest request) {
    // 检查医生当日加号上限（5个）
    Schedule schedule = scheduleRepository.findById(request.getScheduleId())
        .orElseThrow(() -> new ResourceNotFoundException("排班不存在"));
    
    long addOnCount = appointmentRepository.countByScheduleAndIsAddOn(
        schedule, true);
    if (addOnCount >= 5) {
        throw new BadRequestException("医生当日加号已达上限（5个）");
    }
    
    // 创建加号预约（直接创建，无需审批）
    Appointment addOn = new Appointment();
    addOn.setPatient(patientRepository.findById(request.getPatientId())
        .orElseThrow(() -> new ResourceNotFoundException("患者不存在")));
    addOn.setSchedule(schedule);
    addOn.setAppointmentType(AppointmentType.ADD_ON);
    addOn.setIsAddOn(true);
    addOn.setStatus(AppointmentStatus.scheduled); // 直接创建为已预约状态
    addOn.setPaymentStatus(PaymentStatus.unpaid); // 加号需要支付
    // ... 其他字段设置
    
    return convertToResponseDto(appointmentRepository.save(addOn));
}
```

### 5. 实现当日复诊功能

**需要新增**：
1. 复诊号创建接口（分诊台端）
2. 复诊号类型判断（同医生/不同医生）

**实现步骤**：

```java
// 1. 创建复诊号DTO
public class FollowUpRequest {
    private Integer originalAppointmentId; // 原始预约ID
    private Integer scheduleId;            // 复诊排班ID（可能不同医生）
    private Integer patientId;
}

// 2. 创建复诊号
@Transactional
public AppointmentResponse createFollowUp(FollowUpRequest request) {
    // 查询原始预约
    Appointment original = appointmentRepository.findById(request.getOriginalAppointmentId())
        .orElseThrow(() -> new ResourceNotFoundException("原始预约不存在"));
    
    // 判断是否同医生
    Schedule originalSchedule = original.getSchedule();
    Schedule followUpSchedule = scheduleRepository.findById(request.getScheduleId())
        .orElseThrow(() -> new ResourceNotFoundException("排班不存在"));
    
    boolean sameDoctor = originalSchedule.getDoctor().getDoctorId()
        .equals(followUpSchedule.getDoctor().getDoctorId());
    
    // 创建复诊号
    Appointment followUp = new Appointment();
    followUp.setAppointmentType(sameDoctor ? 
        AppointmentType.SAME_DAY_FOLLOW_UP : AppointmentType.NEXT_DAY_FOLLOW_UP);
    followUp.setOriginalAppointmentId(request.getOriginalAppointmentId());
    followUp.setSchedule(followUpSchedule);
    followUp.setStatus(AppointmentStatus.scheduled);
    // ... 其他字段设置
    
    return convertToResponseDto(appointmentRepository.save(followUp));
}
```

### 6. 调整迟到处理逻辑

**规则**：
- 时段结束前10分钟之后但未到时段结束：允许签到，标记为迟到，排末尾
- 时段已结束：不允许签到，需改约或退号

**修改位置**：`AppointmentService.checkIn()` 方法（已在第1点中说明）

## 三、数据库变更

### 需要新增的字段（已存在，无需新增）

所有需要的字段都已经在 `Appointment` 实体中存在：
- `appointment_type` ✅
- `is_add_on` ✅
- `is_priority` ✅
- `original_appointment_id` ✅
- `real_time_queue_number` ✅
- `is_late` ✅
- `recheck_in_time` ✅

### 需要新增的状态（可选）

如果需要加号审批流程，可以新增状态：
- `PENDING_APPROVAL`：待审批（加号申请）

## 四、接口清单

### 患者端接口

1. **预约挂号**：`POST /api/appointments` ✅（已实现）
2. **现场挂号**：`POST /api/appointments/walk-in` ❌（需要新增）
3. **签到**：`POST /api/appointments/check-in` ✅（已实现，需调整时间窗口）
4. **过号重新签到**：`POST /api/appointments/{id}/recheck-in` ✅（已实现，需验证逻辑）
5. **查询队列**：`GET /api/appointments/queue/{scheduleId}` ✅（已实现）

### 医生端接口

1. **查看队列**：`GET /api/appointments/queue/{scheduleId}` ✅（已实现）
2. **叫号**：`POST /api/appointments/{id}/call` ✅（已实现）
3. **紧急加号**：`POST /api/appointments/add-on` ❌（需要新增）
4. **查看当日加号数量**：`GET /api/appointments/add-on/count/{scheduleId}` ❌（需要新增）

### 分诊台端接口

1. **创建复诊号**：`POST /api/appointments/follow-up` ❌（需要新增）
2. **扫码签到**：`POST /api/appointments/check-in` ✅（已实现）
3. **手动调整队列**：`POST /api/appointments/queue/{scheduleId}/adjust` ❌（需要新增）

## 五、实现优先级

### 高优先级（核心功能）

1. ✅ 调整签到时间窗口
2. ✅ 修复过号处理逻辑（排当前时段队尾）
3. ✅ 验证复诊号插入逻辑

### 中优先级（重要功能）

4. ⚠️ 实现加号功能（申请+审批）
5. ⚠️ 实现当日复诊功能

### 低优先级（优化功能）

6. ⚠️ 实现现场挂号接口
7. ⚠️ 实现手动调整队列功能

## 六、测试要点

1. **签到时间窗口测试**：
   - 时段开始前15分钟之前：不允许签到
   - 时段开始前15分钟至结束前10分钟：正常签到
   - 时段结束前10分钟之后但未结束：允许签到但标记迟到
   - 时段已结束：不允许签到

2. **过号处理测试**：
   - 过号后重新签到：排当前时段队尾
   - 验证实时候诊序号是否正确

3. **复诊号插入测试**：
   - 同医生复诊：每两位正常患者后插入一个
   - 不同医生复诊：排在新医生所有患者末尾

4. **加号功能测试**：
   - 加号申请：检查当日加号上限
   - 加号审批：医生同意后排在所有正常号末尾
   - 加号排序：按医生同意时间排序

## 七、总结

**当前代码基础良好**，大部分字段和基础逻辑都已实现。主要需要：

1. **调整签到时间窗口**（从软关门5分钟改为开始前15分钟至结束前10分钟）
2. **修复过号处理**（从顺延5个改为排当前时段队尾）
3. **新增加号和复诊号创建接口**
4. **验证和完善现有排序逻辑**

这些修改都是**增量修改**，不会影响现有功能，可以逐步实现和测试。

