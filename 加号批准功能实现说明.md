# 加号批准功能实现说明

## 问题分析

### 原始错误
从截图中看到的 409 Conflict 错误，根本原因是：
- `schedules` 表有唯一约束：`UNIQUE(doctor_id, schedule_date, slot_id)`
- 原实现尝试创建"虚拟号源"，使用与原排班相同的医生、日期、时段
- 这违反了唯一约束，导致数据库插入失败

## 解决方案

### 修改策略
**不再创建虚拟号源**，而是直接在原排班上增加号源数量：

1. **批准加号时**：
   - 获取原始排班记录
   - 将 `totalSlots` 增加加号数量
   - 在 `remarks` 中记录加号信息
   - 创建加号预约记录（标记为 `ADD_ON` 类型）
   - 设置 24 小时支付截止时间

2. **支付成功时**：
   - 更新预约状态为 `scheduled`
   - 增加排班的 `bookedSlots`

3. **支付超时时**：
   - 取消预约
   - 减少排班的 `totalSlots`（释放号源）
   - 通知患者

## 核心代码修改

### 1. AddOnSlotService.java
```java
// 不再创建虚拟号源，直接修改原排班
Schedule schedule = scheduleRepository.findById(application.getScheduleId())
        .orElseThrow(() -> new RuntimeException("原排班不存在"));

// 增加总号源数量
Integer originalTotalSlots = schedule.getTotalSlots();
schedule.setTotalSlots(originalTotalSlots + application.getAddedSlots());
schedule.setRemarks((schedule.getRemarks() != null ? schedule.getRemarks() + "; " : "") + 
        "加号+" + application.getAddedSlots() + "(申请ID:" + application.getApplicationId() + ")");
scheduleRepository.save(schedule);

// 创建预约记录
Appointment appointment = createAddOnAppointment(application, schedule);
```

### 2. AddOnPaymentExpirationTask.java
```java
// 超时时减少totalSlots来释放号源
Schedule schedule = appointment.getSchedule();
if (schedule != null && appointment.getIsAddOn()) {
    Integer currentTotal = schedule.getTotalSlots();
    if (currentTotal > 0) {
        schedule.setTotalSlots(currentTotal - 1);
        scheduleRepository.save(schedule);
    }
}
```

## 完整流程

### 1. 医生申请加号
- 医生选择自己的排班
- 指定患者和加号数量
- 填写申请理由和紧急程度
- 提交申请（状态：PENDING）

### 2. 管理员审批
**批准流程**：
```
POST /api/slot-applications/{id}
{
  "status": "APPROVED",
  "approverId": 1,
  "approverComments": "批准理由"
}
```

**后端处理**：
1. 验证申请状态（防止重复批准）
2. 更新申请状态为 APPROVED
3. 增加原排班的 totalSlots
4. 创建加号预约记录（状态：PENDING_PAYMENT）
5. 设置支付截止时间（当前时间 + 24小时）
6. 发送通知给医生和患者

### 3. 患者支付
- 患者在 24 小时内完成支付
- 支付成功后：
  - 预约状态变为 scheduled
  - 排班的 bookedSlots + 1

### 4. 超时处理
- 定时任务每分钟检查一次
- 发现超时未支付的加号预约：
  - 取消预约
  - 减少排班的 totalSlots
  - 通知患者

## 数据库字段

### schedules 表（已有字段）
- `is_add_on_slot`: 不再使用（保留以兼容旧代码）
- `reserved_for_patient_id`: 不再使用
- `slot_application_id`: 不再使用

### appointments 表
- `payment_deadline`: 支付截止时间（加号专用）
- `appointment_type`: ADD_ON（加号类型）
- `is_add_on`: true（标记为加号）
- `status`: PENDING_PAYMENT → scheduled/cancelled
- `payment_status`: unpaid → paid

### slot_application 表
- `appointment_id`: 关联生成的预约ID

## 测试步骤

### 1. 准备测试数据
```sql
-- 确保有医生排班
SELECT * FROM schedules WHERE doctor_id = 1 AND schedule_date >= CURDATE();

-- 确保有患者
SELECT * FROM patients LIMIT 1;
```

### 2. 创建加号申请
```bash
# 使用 Postman 或前端创建申请
POST /api/slot-applications
{
  "doctorId": 1,
  "scheduleId": 1,
  "addedSlots": 2,
  "patientId": 1,
  "urgencyLevel": "MEDIUM",
  "reason": "患者病情紧急，需要加号"
}
```

### 3. 管理员批准
- 登录管理员后台
- 进入"加号申请审批管理"页面
- 点击"批准"按钮
- 填写审批意见（可选）
- 确认批准

### 4. 验证结果
```sql
-- 检查申请状态
SELECT * FROM slot_application WHERE application_id = 1;

-- 检查排班号源数量是否增加
SELECT schedule_id, total_slots, booked_slots, remarks 
FROM schedules WHERE schedule_id = 1;

-- 检查是否生成预约记录
SELECT appointment_id, status, payment_status, payment_deadline, is_add_on
FROM appointments WHERE appointment_type = 'ADD_ON' 
ORDER BY created_at DESC LIMIT 1;

-- 检查通知是否发送
SELECT * FROM notifications 
WHERE related_entity = 'appointment' 
ORDER BY created_at DESC LIMIT 2;
```

### 5. 测试支付流程
```bash
# 模拟支付成功
# 需要调用支付接口（具体接口根据系统实现）
```

### 6. 测试超时处理
```sql
-- 手动修改支付截止时间为过去时间
UPDATE appointments 
SET payment_deadline = DATE_SUB(NOW(), INTERVAL 1 HOUR)
WHERE appointment_id = {刚创建的预约ID};

-- 等待定时任务执行（最多1分钟）
-- 或手动触发定时任务

-- 验证预约是否被取消
SELECT status FROM appointments WHERE appointment_id = {预约ID};

-- 验证号源是否被释放
SELECT total_slots FROM schedules WHERE schedule_id = 1;
```

## 注意事项

1. **并发控制**：
   - 使用 `@Transactional` 确保原子性
   - 数据库层面的乐观锁或悲观锁

2. **错误处理**：
   - 详细的日志记录
   - 友好的错误提示
   - 防止重复批准

3. **通知机制**：
   - 批准后立即通知医生和患者
   - 支付成功后通知
   - 超时后通知

4. **数据一致性**：
   - 确保 totalSlots >= bookedSlots
   - 支付超时后正确释放号源
   - 申请状态与预约状态保持一致

## 常见问题

### Q1: 为什么不创建虚拟号源？
A: 因为 schedules 表有唯一约束 `(doctor_id, schedule_date, slot_id)`，创建虚拟号源会违反此约束。直接修改原排班更简单且不需要修改数据库结构。

### Q2: 如果多个加号申请同时批准会怎样？
A: 使用事务隔离级别和数据库锁机制确保并发安全。每次批准都会原子性地增加 totalSlots。

### Q3: 支付超时后号源如何释放？
A: 定时任务会自动减少 totalSlots，确保号源被释放。同时取消预约并通知患者。

### Q4: 如何防止重复批准？
A: 在批准前检查申请状态，如果已经是 APPROVED 状态则抛出异常。

## 后续优化建议

1. **支付期限配置化**：
   - 将 24 小时改为可配置参数
   - 不同紧急程度可以有不同的支付期限

2. **批量批准**：
   - 支持管理员一次批准多个申请

3. **统计报表**：
   - 加号申请统计
   - 支付成功率统计
   - 超时率统计

4. **审批流程优化**：
   - 多级审批
   - 自动审批规则

5. **患者端功能**：
   - 患者可以查看自己的加号预约
   - 支付倒计时提醒
