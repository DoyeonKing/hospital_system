# 医院管理系统 - 用户故事

## 用户故事 1：患者通过预约获取导航路径

### Story name
患者通过预约获取导航路径

### Story ID
HOSPITAL-001

### 用户故事描述
**As a** 已预约患者  
**I want** 通过我的预约信息自动获取到诊室的导航路径  
**So that** 我可以快速找到诊室位置，避免在医院内迷路，准时到达就诊地点

### Priority
Should have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 患者已经成功预约挂号，预约状态为"已预约"或"已支付"  
**When** 患者打开导航页面并选择"通过预约导航"  
**Then** 系统应：
1. 自动获取患者最近的预约信息
2. 根据预约关联的诊室位置（location）获取对应的地图节点（mapNode）
3. 如果患者已扫码定位当前位置，则从当前位置规划路径
4. 如果患者未定位，则提示选择起点（如医院入口）
5. 使用A*算法计算最优路径
6. 显示完整的导航路径，包括：
   - 路径节点列表
   - 总距离
   - 是否需要跨楼层
   - 跨楼层提示信息（如"请乘坐电梯到3楼"）
   - 逐步导航指引

**Given** 患者没有有效预约  
**When** 患者尝试通过预约获取导航  
**Then** 系统应提示"您当前没有有效预约，请先预约挂号"

**Given** 预约的诊室没有关联地图节点  
**When** 患者尝试通过预约获取导航  
**Then** 系统应显示诊室的基本位置信息（建筑、楼层、房间号），但无法提供详细导航路径

### Notes
- 需要关联Appointment、Schedule、Location、MapNode等表
- 支持跨楼层导航，需要显示楼层切换提示
- 如果患者有多个预约，显示最近的预约

---

## 用户故事 2：患者扫码定位当前位置

### Story name
患者扫码定位当前位置

### Story ID
HOSPITAL-002

### 用户故事描述
**As a** 在医院内的患者  
**I want** 通过扫描医院内的二维码来定位我当前所在位置  
**So that** 系统可以知道我的起点，为我提供准确的导航路径

### Priority
Must have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 患者在医院内的某个位置（如大厅、电梯口、诊室门口）  
**When** 患者使用手机扫描该位置的二维码  
**Then** 系统应：
1. 解析二维码内容（格式：HOSPITAL_NODE_{nodeId}）
2. 验证二维码格式是否正确
3. 根据nodeId查询对应的地图节点信息
4. 返回节点详细信息，包括：
   - 节点ID
   - 节点名称（如"一楼大厅"、"3楼电梯口"）
   - 所在建筑
   - 所在楼层
   - 节点类型（entrance、elevator、stairs、room等）
   - 坐标信息
5. 将当前位置保存为用户当前起点
6. 提示"定位成功，当前位置：{节点名称}"

**Given** 患者扫描的二维码格式不正确  
**When** 患者扫描二维码  
**Then** 系统应提示"无效的二维码格式，应为 HOSPITAL_NODE_{nodeId}"

**Given** 患者扫描的二维码对应的节点不存在  
**When** 患者扫描二维码  
**Then** 系统应提示"节点不存在，请扫描有效的医院位置二维码"

**Given** 患者已成功定位当前位置  
**When** 患者请求导航到某个目标位置  
**Then** 系统应使用已定位的位置作为路径规划的起点

### Notes
- 二维码格式：HOSPITAL_NODE_{nodeId}，其中nodeId为整数
- 支持多种节点类型：entrance（入口）、elevator（电梯）、stairs（楼梯）、room（房间）等
- 定位成功后，当前位置应保存在前端状态中，用于后续导航

---

## 用户故事 3：患者签到后查看实时排队信息

### Story name
患者签到后查看实时排队信息

### Story ID
HOSPITAL-003

### 用户故事描述
**As a** 已预约并签到的患者  
**I want** 查看我在当前时段的实时排队信息和叫号状态  
**So that** 我可以了解前面还有多少人，合理安排等待时间，避免错过叫号

### Priority
Must have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 患者已成功预约挂号，预约状态为"scheduled"  
**When** 患者在预约时段开始前15分钟至结束前10分钟内进行签到  
**Then** 系统应：
1. 更新预约状态为"CHECKED_IN"（已签到）
2. 记录签到时间（check_in_time）
3. 根据签到时间分配实时候诊序号（real_time_queue_number）
4. 返回签到成功信息，包括：
   - 预约信息（医生姓名、科室、诊室）
   - 实时候诊序号
   - 当前时段总排队人数
   - 预计等待时间

**Given** 患者已签到  
**When** 患者查看排队信息页面  
**Then** 系统应显示：
1. 当前实时候诊序号
2. 当前正在就诊的序号（已叫号但未完成的）
3. 前面还有多少人等待
4. 当前叫号状态（是否已叫号）
5. 如果已叫号，显示叫号时间
6. 如果过号，显示过号次数和重新签到提示

**Given** 患者已签到但未叫号  
**When** 医生叫号后  
**Then** 系统应：
1. 更新预约的called_at字段
2. 通过消息推送通知患者"请到{诊室}就诊"
3. 更新排队信息，显示"正在就诊"

**Given** 患者过号后  
**When** 患者重新签到  
**Then** 系统应：
1. 增加过号次数（missed_call_count + 1）
2. 记录重新签到时间（recheck_in_time）
3. 将患者排到当前时段的队尾
4. 重新分配实时候诊序号

**Given** 患者尝试在时段开始前15分钟之前签到  
**When** 患者进行签到  
**Then** 系统应提示"签到时间未到，请在时段开始前15分钟至结束前10分钟内签到"

**Given** 患者尝试在时段结束前10分钟之后签到  
**When** 患者进行签到  
**Then** 系统应允许签到但标记为迟到（is_late = true），并提示"您已迟到，请尽快前往诊室"

### Notes
- 实时候诊序号按签到时间顺序分配，同一时段内先签到的人序号更小
- 过号后重新签到排在当前时段队尾，不影响其他患者的序号
- 需要实时更新排队信息，建议使用WebSocket或轮询机制
- 排队信息查询需要关联appointments表和schedules表

---

## 用户故事 4：患者搜索诊室位置

### Story name
患者搜索诊室位置

### Story ID
HOSPITAL-004

### 用户故事描述
**As a** 需要找诊室的患者  
**I want** 通过输入诊室名称或关键词来搜索诊室位置  
**So that** 我可以快速找到目标诊室，即使我不知道具体的楼层和房间号

### Priority
Should have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 患者打开搜索页面  
**When** 患者输入诊室名称或关键词（如"内科"、"301"、"放射科"）  
**Then** 系统应：
1. 实时搜索匹配的节点和诊室
2. 同时搜索MapNode的nodeName和Location的locationName
3. 返回匹配结果列表，每个结果包括：
   - 节点/诊室名称
   - 所在建筑
   - 所在楼层
   - 房间号（如果有）
   - 节点类型
   - 描述信息
4. 搜索结果按相关度排序（完全匹配优先）
5. 如果无匹配结果，提示"未找到相关诊室"

**Given** 患者搜索关键词为空或只包含空格  
**When** 患者进行搜索  
**Then** 系统应返回空列表，不执行搜索

**Given** 患者从搜索结果中选择一个诊室  
**When** 患者点击"导航到此"  
**Then** 系统应：
1. 获取该诊室的地图节点信息
2. 如果患者已定位当前位置，直接规划路径
3. 如果患者未定位，提示选择起点或扫码定位
4. 显示导航路径和指引信息

**Given** 搜索的诊室关联了多个地图节点  
**When** 系统返回搜索结果  
**Then** 系统应显示所有关联的节点，让患者选择具体位置

**Given** 患者搜索"入口"或"大厅"  
**When** 系统搜索  
**Then** 系统应优先返回节点类型为"entrance"的节点

### Notes
- 搜索功能支持模糊匹配，不区分大小写
- 同时搜索MapNode表和Location表，通过关联的mapNode转换为统一的结果格式
- 如果Location没有关联MapNode，创建临时的MapNodeDto返回
- 搜索结果去重，使用LinkedHashSet保持顺序
- 支持中英文搜索

---

## 用户故事总结

### 优先级分布
- **Must have（必须支持）**：2个
  - HOSPITAL-002：患者扫码定位当前位置
  - HOSPITAL-003：患者签到后查看实时排队信息

- **Should have（应该支持）**：2个
  - HOSPITAL-001：患者通过预约获取导航路径
  - HOSPITAL-004：患者搜索诊室位置

### INVEST原则检查

| 故事ID | Independent | Negotiable | Valuable | Estimable | Small | Testable |
|--------|------------|------------|----------|-----------|-------|----------|
| HOSPITAL-001 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-002 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-003 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-004 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

### 功能依赖关系

```
HOSPITAL-002 (扫码定位)
    ↓
HOSPITAL-001 (预约导航) ──→ 需要定位作为起点
HOSPITAL-004 (搜索诊室) ──→ 可选择导航功能

HOSPITAL-003 (排队信息) ──→ 独立功能，依赖预约和签到
```

### 技术实现要点

1. **HOSPITAL-001**：
   - 需要关联Appointment → Schedule → Location → MapNode
   - 使用NavigationService的planRoute方法
   - 支持跨楼层导航提示

2. **HOSPITAL-002**：
   - 使用NavigationService的scanLocation方法
   - 二维码格式验证和解析
   - 节点信息缓存查询

3. **HOSPITAL-003**：
   - 需要AppointmentService的签到和查询功能
   - 实时队列计算（按签到时间排序）
   - 过号处理逻辑

4. **HOSPITAL-004**：
   - 使用NavigationService的searchNodes方法
   - 多表联合搜索（MapNode + Location）
   - 搜索结果去重和排序

---

## 用户故事 5：管理员创建单个排班

### Story name
管理员创建单个排班

### Story ID
HOSPITAL-005

### 用户故事描述
**As a** 医院管理员  
**I want** 为医生创建单个排班记录  
**So that** 我可以安排医生在特定时间、特定诊室出诊，确保患者能够预约到合适的就诊时间

### Priority
Must have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 管理员已登录系统并进入排班管理页面  
**When** 管理员填写排班信息（选择医生、日期、时间段、诊室、号源数量、费用）并提交  
**Then** 系统应：
1. 验证必填字段（医生、日期、时间段、诊室）
2. 验证医生是否存在且状态为"active"
3. 验证时间段是否存在
4. 验证诊室是否存在
5. 检查该医生在该时间段是否已有排班（防止重复排班）
6. 如果无冲突，创建排班记录，状态为"available"
7. 返回创建成功的排班信息
8. 在排班看板上显示新创建的排班

**Given** 管理员尝试为同一医生在同一时间段创建排班  
**When** 系统检测到已有排班  
**Then** 系统应：
1. 拒绝创建，提示"该医生在该时间段已有排班"
2. 显示冲突的排班信息
3. 建议管理员修改日期或时间段

**Given** 管理员填写的必填字段不完整  
**When** 管理员提交创建排班  
**Then** 系统应提示"请填写完整的排班信息"，并高亮显示缺失的字段

**Given** 管理员选择的医生不存在或状态为"inactive"  
**When** 管理员提交创建排班  
**Then** 系统应提示"选择的医生不存在或已停用"

### Notes
- 排班三要素：医生 + 时间 + 地点
- 创建排班时需要检查基础冲突（医生重复排班）
- 创建成功后，系统可以自动触发冲突检测（但这是另一个故事）

---

## 用户故事 6：管理员批量导入排班

### Story name
管理员批量导入排班

### Story ID
HOSPITAL-006

### 用户故事描述
**As a** 医院管理员  
**I want** 通过Excel文件批量导入排班数据  
**So that** 我可以快速为多个医生创建多个排班，提高排班效率，避免逐个手动创建

### Priority
Should have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 管理员已登录系统并进入排班管理页面  
**When** 管理员下载排班导入模板  
**Then** 系统应：
1. 提供Excel模板文件下载
2. 模板包含必要的列：医生工号、日期、时间段ID、诊室ID、号源数量、费用
3. 模板包含示例数据和格式说明

**Given** 管理员已填写好Excel文件  
**When** 管理员上传Excel文件进行批量导入  
**Then** 系统应：
1. 验证文件格式（必须是Excel文件）
2. 解析Excel文件，读取每一行数据
3. 逐行验证数据：
   - 验证医生工号是否存在
   - 验证时间段ID是否存在
   - 验证诊室ID是否存在
   - 验证日期格式是否正确
   - 检查该行数据是否与已有排班冲突
4. 收集所有验证错误，记录错误行号和错误原因
5. 对于验证通过的行，批量插入数据库
6. 返回导入结果：
   - 成功导入的记录数
   - 失败的记录数
   - 详细的错误信息列表（包含行号和错误原因）

**Given** 导入过程中部分记录验证失败  
**When** 系统完成导入  
**Then** 系统应：
1. 成功导入验证通过的记录
2. 显示详细的失败记录列表
3. 允许管理员下载错误报告
4. 提示管理员修正错误后重新导入

**Given** Excel文件格式不正确或为空  
**When** 管理员上传文件  
**Then** 系统应提示"文件格式错误，请使用正确的Excel模板"

**Given** 批量导入完成后  
**When** 系统检测到新导入的排班  
**Then** 系统应自动触发冲突检测，高亮显示冲突的排班

### Notes
- 批量导入可以提高效率，但需要严格的数据验证
- 支持部分成功导入（部分记录失败不影响其他记录）
- 导入模板应包含清晰的格式说明和示例
- 错误报告应详细，便于管理员修正

---

## 用户故事 7：管理员检测医生重复排班冲突

### Story name
管理员检测医生重复排班冲突

### Story ID
HOSPITAL-007

### 用户故事描述
**As a** 医院管理员  
**I want** 系统自动检测并高亮显示医生重复排班冲突  
**So that** 我可以及时发现并解决同一医生在同一时间段被安排了多个排班的问题，确保排班数据的准确性

### Priority
Must have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 排班看板中已有排班数据  
**When** 管理员点击"检测冲突"按钮或系统自动触发冲突检测  
**Then** 系统应：
1. 扫描所有排班记录
2. 检测是否存在同一医生在同一日期、同一时间段有多个排班
3. 对于发现的冲突：
   - 标记冲突类型为"医生重复排班"（doctor_double_booking）
   - 标记严重程度为"critical"（严重）
   - 记录冲突涉及的排班ID
   - 记录冲突的医生、日期、时间段信息
4. 在排班看板上用红色高亮显示冲突的排班
5. 显示冲突摘要：总冲突数、严重冲突数
6. 提供冲突详情列表，包括：
   - 冲突的医生姓名
   - 冲突的日期和时间段
   - 涉及的排班ID
   - 建议操作（如"请删除其中一个排班"）

**Given** 管理员点击冲突的排班卡片  
**When** 查看冲突详情  
**Then** 系统应显示：
1. 该冲突涉及的所有排班信息
2. 冲突的具体原因
3. 建议的解决方案

**Given** 系统未检测到医生重复排班冲突  
**When** 冲突检测完成  
**Then** 系统应显示"未发现医生重复排班冲突"

**Given** 管理员修改或删除了冲突的排班  
**When** 系统重新检测冲突  
**Then** 系统应更新冲突列表，移除已解决的冲突

### Notes
- 这是冲突检测功能的一部分，但作为独立故事实现
- 只检测医生重复排班这一种冲突类型
- 其他冲突类型（如办公室冲突、工作时间冲突）是独立的故事
- 冲突检测可以在创建/导入排班后自动触发，也可以手动触发

---

## 用户故事 8：管理员检测办公室冲突

### Story name
管理员检测办公室冲突

### Story ID
HOSPITAL-008

### 用户故事描述
**As a** 医院管理员  
**I want** 系统自动检测并高亮显示办公室冲突  
**So that** 我可以及时发现同一诊室在同一时间段被多个医生占用的问题，避免诊室资源冲突

### Priority
Should have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 排班看板中已有排班数据  
**When** 管理员触发冲突检测或系统自动检测  
**Then** 系统应：
1. 扫描所有排班记录
2. 检测是否存在同一诊室（location）在同一日期、同一时间段被多个医生占用
3. 对于发现的冲突：
   - 标记冲突类型为"办公室冲突"（office_conflict）
   - 标记严重程度为"critical"（严重）
   - 记录冲突涉及的排班ID和医生ID列表
   - 记录冲突的诊室、日期、时间段信息
4. 在排班看板上用红色高亮显示冲突的排班
5. 在冲突摘要中统计办公室冲突数量
6. 提供冲突详情，包括：
   - 冲突的诊室名称
   - 冲突的日期和时间段
   - 涉及的医生列表
   - 涉及的排班ID列表
   - 建议操作（如"请为其中一个排班分配其他诊室"）

**Given** 管理员查看办公室冲突详情  
**When** 查看冲突列表  
**Then** 系统应显示所有冲突的诊室，每个冲突显示涉及的医生和排班信息

**Given** 管理员修改了冲突排班的诊室  
**When** 系统重新检测冲突  
**Then** 系统应更新冲突列表，移除已解决的办公室冲突

**Given** 系统未检测到办公室冲突  
**When** 冲突检测完成  
**Then** 系统应不显示办公室冲突相关信息

### Notes
- 这是独立的冲突检测功能，与医生重复排班检测分开
- 办公室冲突是严重冲突，需要及时解决
- 一个诊室在同一时间段只能被一个医生使用

---

## 用户故事 9：管理员修改排班信息

### Story name
管理员修改排班信息

### Story ID
HOSPITAL-009

### 用户故事描述
**As a** 医院管理员  
**I want** 修改已创建的排班信息（如修改时间段、诊室、号源数量、费用）  
**So that** 我可以根据实际情况调整排班安排，适应医生请假、诊室变更等突发情况

### Priority
Must have

### Date started
（待填写）

### Date Finished
（待填写）

### Acceptance Criteria

**Given** 管理员已登录系统并查看排班列表  
**When** 管理员选择某个排班并点击"修改"  
**Then** 系统应：
1. 显示排班编辑表单，预填充当前排班信息
2. 允许修改的字段包括：
   - 日期
   - 时间段
   - 诊室
   - 号源数量（total_slots）
   - 费用（fee）
3. 不允许修改的字段：
   - 医生（如需修改医生，应删除后重新创建）
   - 已预约数量（booked_slots，由系统自动维护）

**Given** 管理员修改了排班信息并提交  
**When** 系统保存修改  
**Then** 系统应：
1. 验证修改后的数据（医生、时间段、诊室是否存在）
2. 检查修改后是否产生新的冲突（如医生重复排班、办公室冲突）
3. 如果无冲突，更新排班记录
4. 如果该排班已有预约，检查修改是否影响已有预约：
   - 如果修改了时间段或诊室，提示"该排班已有预约，修改可能影响患者"
   - 如果修改了号源数量且新数量小于已预约数量，拒绝修改并提示
5. 返回修改成功的提示
6. 在排班看板上更新显示

**Given** 管理员修改排班后产生冲突  
**When** 系统检测到冲突  
**Then** 系统应：
1. 拒绝保存修改
2. 提示冲突信息（如"该医生在该时间段已有其他排班"）
3. 显示冲突的排班详情
4. 建议管理员调整修改内容

**Given** 管理员修改了已有预约的排班的号源数量  
**When** 新数量小于已预约数量  
**Then** 系统应拒绝修改，提示"号源数量不能小于已预约数量（当前已预约X个）"

**Given** 管理员修改了排班的诊室  
**When** 该排班已有预约  
**Then** 系统应：
1. 允许修改，但提示"诊室变更，请通知相关患者"
2. 建议发送通知给已预约的患者
3. 更新排班记录

### Notes
- 修改排班时需要谨慎，特别是已有预约的排班
- 修改后应自动触发冲突检测
- 如果修改影响患者，应考虑发送通知（这是另一个故事）

---

## 用户故事总结（更新）

### 优先级分布
- **Must have（必须支持）**：4个
  - HOSPITAL-002：患者扫码定位当前位置
  - HOSPITAL-003：患者签到后查看实时排队信息
  - HOSPITAL-005：管理员创建单个排班
  - HOSPITAL-009：管理员修改排班信息

- **Should have（应该支持）**：5个
  - HOSPITAL-001：患者通过预约获取导航路径
  - HOSPITAL-004：患者搜索诊室位置
  - HOSPITAL-006：管理员批量导入排班
  - HOSPITAL-007：管理员检测医生重复排班冲突
  - HOSPITAL-008：管理员检测办公室冲突

### INVEST原则检查

| 故事ID | Independent | Negotiable | Valuable | Estimable | Small | Testable |
|--------|------------|------------|----------|-----------|-------|----------|
| HOSPITAL-001 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-002 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-003 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-004 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-005 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-006 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-007 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-008 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| HOSPITAL-009 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |

### 功能依赖关系

```
HOSPITAL-002 (扫码定位)
    ↓
HOSPITAL-001 (预约导航) ──→ 需要定位作为起点
HOSPITAL-004 (搜索诊室) ──→ 可选择导航功能

HOSPITAL-003 (排队信息) ──→ 独立功能，依赖预约和签到

HOSPITAL-005 (创建排班) ──→ 基础功能
    ↓
HOSPITAL-006 (批量导入) ──→ 依赖创建排班功能
HOSPITAL-007 (检测医生冲突) ──→ 依赖排班数据
HOSPITAL-008 (检测办公室冲突) ──→ 依赖排班数据
HOSPITAL-009 (修改排班) ──→ 依赖排班数据
```

### 故事拆分说明

根据PPT中的案例分析，我将大的"排班管理"功能拆分如下：

1. **避免复合故事**：
   - ❌ 错误示例："管理员可以创建、修改和删除排班"（复合故事）
   - ✅ 正确做法：拆分为HOSPITAL-005（创建）、HOSPITAL-009（修改），删除功能可以单独作为HOSPITAL-010

2. **避免故事过大**：
   - ❌ 错误示例："管理员可以管理所有排班冲突"（故事太大）
   - ✅ 正确做法：拆分为HOSPITAL-007（检测医生冲突）和HOSPITAL-008（检测办公室冲突）

3. **确保用户价值**：
   - ✅ 所有故事都从管理员角度描述，明确业务价值
   - ✅ 避免纯技术描述（如"使用A*算法"），而是描述用户价值（如"快速找到诊室"）

### 技术实现要点

1. **HOSPITAL-001**：
   - 需要关联Appointment → Schedule → Location → MapNode
   - 使用NavigationService的planRoute方法
   - 支持跨楼层导航提示

2. **HOSPITAL-002**：
   - 使用NavigationService的scanLocation方法
   - 二维码格式验证和解析
   - 节点信息缓存查询

3. **HOSPITAL-003**：
   - 需要AppointmentService的签到和查询功能
   - 实时队列计算（按签到时间排序）
   - 过号处理逻辑

4. **HOSPITAL-004**：
   - 使用NavigationService的searchNodes方法
   - 多表联合搜索（MapNode + Location）
   - 搜索结果去重和排序

5. **HOSPITAL-005**：
   - 使用ScheduleService的createSchedule方法
   - 基础数据验证（医生、时间段、诊室）
   - 简单冲突检查（医生重复排班）

6. **HOSPITAL-006**：
   - Excel文件解析（Apache POI或EasyExcel）
   - 批量数据验证
   - 事务处理（部分成功导入）

7. **HOSPITAL-007**：
   - 冲突检测算法：按医生+日期+时间段分组
   - 高亮显示冲突排班
   - 冲突详情展示

8. **HOSPITAL-008**：
   - 冲突检测算法：按诊室+日期+时间段分组
   - 识别多个医生占用同一诊室的情况
   - 冲突详情展示

9. **HOSPITAL-009**：
   - 使用ScheduleService的updateSchedule方法
   - 修改前验证（特别是已有预约的情况）
   - 修改后冲突检测

