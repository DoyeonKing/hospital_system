# 叫号规则功能测试方案（患者端）

## 测试概述

**测试目标**：验证医院挂号系统叫号规则的完整性和正确性  
**测试范围**：患者端叫号、签到、排队、过号重排等核心功能  
**测试环境**：开发环境/测试环境  
**测试人员**：测试工程师  
**测试日期**：待填写

---

## 一、测试环境准备

### 1.1 前置条件

- [ ] 后端服务正常运行（Spring Boot）
- [ ] 前端小程序正常运行（uni-app）
- [ ] 数据库已初始化测试数据
- [ ] 至少2个医生账号（用于创建排班）
- [ ] 至少10个患者账号（用于模拟不同场景）
- [ ] 管理员账号（用于创建排班和加号）

### 1.2 测试数据准备

#### 医生数据
- 医生A：内科，可创建多个排班时段
- 医生B：外科，用于对比测试

#### 排班数据
- 上午时段：09:00-12:00（总号源：10个）
- 下午时段：14:00-17:00（总号源：10个）

#### 患者账号
- 患者1-5：用于预约挂号测试
- 患者6-8：用于现场挂号测试
- 患者9：用于复诊号测试
- 患者10：用于加号测试

---

## 二、测试用例详细设计

### 测试用例 TC-001：预约优先规则

**测试目标**：验证同一时段内，已预约患者永远排在现场挂号患者之前

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1（预约挂号）
   - 患者2预约：挂号序号2（预约挂号）
   - 患者3现场挂号：挂号序号3（现场挂号）
   - 患者4预约：挂号序号4（预约挂号）

2. **执行操作**
   - 患者1签到（08:45，提前签到）
   - 患者3签到（08:50，提前签到）
   - 患者2签到（09:00，时段内签到）
   - 患者4签到（09:05，时段内签到）

3. **验证结果**
   - [ ] 调用叫号队列接口：`GET /api/appointments/doctor/{doctorId}/call-queue`
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者4 → 患者3
   - [ ] 预约挂号患者（1、2、4）都在现场挂号患者（3）之前

#### 预期结果

✅ **通过标准**：
- 所有预约挂号患者排在现场挂号患者之前
- 预约挂号患者内部按签到时间排序
- 现场挂号患者排在最后

❌ **失败标准**：
- 现场挂号患者出现在预约挂号患者之前
- 队列顺序不符合规则

---

### 测试用例 TC-002：先签到先就诊规则（提前签到）

**测试目标**：验证提前签到时，按挂号序号排序

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1
   - 患者2预约：挂号序号2
   - 患者3预约：挂号序号3
   - 患者4预约：挂号序号4

2. **执行操作**
   - 患者4提前签到（08:50，时段开始前10分钟）
   - 患者2提前签到（08:52，时段开始前8分钟）
   - 患者1提前签到（08:55，时段开始前5分钟）
   - 患者3提前签到（08:58，时段开始前2分钟）

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者3 → 患者4
   - [ ] 提前签到的患者按挂号序号排序，与签到时间无关

#### 预期结果

✅ **通过标准**：
- 提前签到的患者按挂号序号（1、2、3、4）排序
- 签到时间不影响排序

❌ **失败标准**：
- 队列顺序与挂号序号不一致
- 按签到时间排序而非挂号序号

---

### 测试用例 TC-003：先签到先就诊规则（时段内签到）

**测试目标**：验证时段内签到时，按签到时间升序生成"实时候诊序号"

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1（提前签到，08:55）
   - 患者2预约：挂号序号2（提前签到，08:58）
   - 患者3预约：挂号序号3（时段内签到，09:05）
   - 患者4预约：挂号序号4（时段内签到，09:10）
   - 患者5预约：挂号序号5（时段内签到，09:08）

2. **执行操作**
   - 患者1提前签到（08:55）
   - 患者2提前签到（08:58）
   - 患者3时段内签到（09:05）
   - 患者5时段内签到（09:08）
   - 患者4时段内签到（09:10）

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者3 → 患者5 → 患者4
   - [ ] 提前签到的患者（1、2）排在前面，按挂号序号
   - [ ] 时段内签到的患者（3、5、4）排在后面，按签到时间（09:05 → 09:08 → 09:10）

#### 预期结果

✅ **通过标准**：
- 提前签到的患者按挂号序号排序
- 时段内签到的患者按签到时间排序
- 提前签到的患者整体排在时段内签到的患者之前

❌ **失败标准**：
- 时段内签到的患者未按签到时间排序
- 提前签到和时段内签到的患者混合排序

---

### 测试用例 TC-004：签到时间窗口（当前实现测试）

**测试目标**：验证当前签到时间窗口的实现（软关门5分钟）

**注意**：此功能未完全实现用户需求，但需要测试当前行为

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1

2. **测试场景1：时段开始前签到**
   - [ ] 患者1在08:45签到（时段开始前15分钟）
   - [ ] 预期：✅ 允许签到

3. **测试场景2：时段开始后签到**
   - [ ] 患者1在09:05签到（时段开始后5分钟）
   - [ ] 预期：✅ 允许签到

4. **测试场景3：时段结束前签到**
   - [ ] 患者1在11:50签到（时段结束前10分钟）
   - [ ] 预期：✅ 允许签到

5. **测试场景4：时段结束后5分钟内签到（软关门）**
   - [ ] 患者1在12:03签到（时段结束后3分钟）
   - [ ] 预期：✅ 允许签到（当前实现）

6. **测试场景5：时段结束后超过5分钟签到**
   - [ ] 患者1在12:10签到（时段结束后10分钟）
   - [ ] 预期：❌ 不允许签到，提示"时段已结束"

#### 预期结果

✅ **通过标准**：
- 时段开始前可以签到
- 时段结束后5分钟内仍可签到（软关门）
- 时段结束后超过5分钟不能签到

⚠️ **待改进**：
- 用户需求：时段开始前15分钟才能开始签到（当前无限制）
- 用户需求：时段结束前10分钟之后算迟到（当前无此限制）
- 用户需求：时段结束后不能签到（当前有5分钟软关门）

---

### 测试用例 TC-005：迟到降档规则（跨场作废）

**测试目标**：验证跨上午/下午场的迟到预约直接作废

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，上午09:00-12:00，总号源10个
   - 患者1预约：挂号序号1，上午时段

2. **执行操作**
   - 患者1在14:00签到（下午时段开始，跨场）

3. **验证结果**
   - [ ] 调用签到接口：`POST /api/appointments/{appointmentId}/check-in`
   - [ ] 返回状态码：400 或 200（但预约状态为已作废）
   - [ ] 预约状态更新为：`cancelled` 或 `expired`
   - [ ] 返回错误信息：提示"跨场次，预约已作废，需重新挂当场号"
   - [ ] 患者需要重新挂下午时段的号

#### 预期结果

✅ **通过标准**：
- 跨场签到直接作废预约
- 返回明确的错误提示
- 预约状态正确更新

❌ **失败标准**：
- 跨场签到成功（不应该成功）
- 预约状态未更新
- 错误提示不明确

---

### 测试用例 TC-006：迟到降档规则（未跨场排末尾）

**测试目标**：验证错过本时段但未跨场的迟到患者，移到当前时段队尾

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1（正常签到，09:00）
   - 患者2预约：挂号序号2（正常签到，09:05）
   - 患者3预约：挂号序号3（迟到签到，10:00）
   - 患者4预约：挂号序号4（正常签到，09:10）

2. **执行操作**
   - 患者1正常签到（09:00）
   - 患者2正常签到（09:05）
   - 患者4正常签到（09:10）
   - 患者3迟到签到（10:00，时段开始后1小时）

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者4 → 患者3
   - [ ] 患者3（迟到）排在队尾
   - [ ] 患者3的预约状态标记为迟到（`isLate: true` 或类似字段）

#### 预期结果

✅ **通过标准**：
- 迟到患者排在队尾
- 正常签到的患者按规则排序
- 迟到标记正确

❌ **失败标准**：
- 迟到患者未排在队尾
- 迟到标记不正确

---

### 测试用例 TC-007：过号重排规则

**测试目标**：验证过号后重新签到，排在当前时段最后一位

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1预约：挂号序号1（正常签到，09:00）
   - 患者2预约：挂号序号2（正常签到，09:05）
   - 患者3预约：挂号序号3（正常签到，09:10）

2. **执行操作**
   - 患者1正常签到（09:00）
   - 患者2正常签到（09:05）
   - 患者3正常签到（09:10）
   - 系统叫号：患者1（09:15）
   - 患者1未进诊室（过号）
   - 患者1重新扫码签到（09:20）
   - 患者4正常签到（09:25）

3. **验证结果**
   - [ ] 调用过号重排接口：`POST /api/appointments/{appointmentId}/recheck-in`
   - [ ] 患者1的实时候诊序号更新为最大值+1
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者2 → 患者3 → 患者4 → 患者1
   - [ ] 患者1（过号重排）排在最后

#### 预期结果

✅ **通过标准**：
- 过号患者重新签到后排在最后
- 实时候诊序号正确更新
- 其他患者顺序不受影响

❌ **失败标准**：
- 过号患者未排在最后
- 实时候诊序号未更新
- 队列顺序错误

---

### 测试用例 TC-008：当日复诊号插入规则

**测试目标**：验证每两位正常挂号患者之后插入一个复诊号

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源20个
   - 患者1-6：正常挂号患者（挂号序号1-6）
   - 患者7-9：复诊号患者（挂号序号7-9，标记为复诊）

2. **执行操作**
   - 患者1-6正常签到（09:00-09:30）
   - 患者7-9复诊号签到（09:00-09:30）

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者7 → 患者3 → 患者4 → 患者8 → 患者5 → 患者6 → 患者9
   - [ ] 每2个正常患者后插入1个复诊号
   - [ ] 复诊号按挂号序号排序

#### 预期结果

✅ **通过标准**：
- 复诊号正确插入，每2个正常患者后1个复诊号
- 复诊号内部按挂号序号排序
- 正常患者内部按规则排序

❌ **失败标准**：
- 复诊号插入位置不正确
- 复诊号未按序号排序

---

### 测试用例 TC-009：加号排在最后规则

**测试目标**：验证加号排在所有正常号末尾

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源10个
   - 患者1-5：正常挂号患者（挂号序号1-5）
   - 患者6：加号患者（挂号序号6，标记为加号）

2. **执行操作**
   - 患者1-5正常签到（09:00-09:30）
   - 患者6加号签到（09:30）

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应为：患者1 → 患者2 → 患者3 → 患者4 → 患者5 → 患者6
   - [ ] 加号患者（患者6）排在所有正常患者之后
   - [ ] 即使加号患者提前签到，也排在最后

#### 预期结果

✅ **通过标准**：
- 加号患者排在所有正常患者之后
- 加号患者之间按挂号序号或签到时间排序

❌ **失败标准**：
- 加号患者出现在正常患者之前
- 加号患者排序不正确

---

### 测试用例 TC-010：综合场景测试

**测试目标**：验证多个规则同时生效时的综合表现

#### 测试步骤

1. **准备数据**
   - 创建排班：医生A，09:00-12:00，总号源20个
   - 患者1-3：预约挂号，提前签到
   - 患者4-5：预约挂号，时段内签到
   - 患者6：现场挂号，提前签到
   - 患者7：预约挂号，迟到签到（未跨场）
   - 患者8-9：复诊号
   - 患者10：加号

2. **执行操作**
   - 按不同时间点签到所有患者
   - 患者1过号后重新签到

3. **验证结果**
   - [ ] 调用叫号队列接口
   - [ ] 队列顺序应符合所有规则：
     - 预约优先于现场挂号
     - 提前签到按序号，时段内按时间
     - 迟到患者排末尾
     - 过号患者排最后
     - 复诊号每2个正常患者后插入
     - 加号排最后

#### 预期结果

✅ **通过标准**：
- 所有规则同时生效
- 队列顺序符合所有规则优先级
- 无规则冲突

❌ **失败标准**：
- 规则冲突
- 队列顺序不符合预期

---

## 三、测试执行计划

### 3.1 测试阶段

| 阶段 | 测试内容 | 预计时间 | 负责人 |
|------|---------|---------|--------|
| 第一阶段 | 基础规则测试（TC-001至TC-003） | 2小时 | 待分配 |
| 第二阶段 | 时间窗口和迟到测试（TC-004至TC-006） | 2小时 | 待分配 |
| 第三阶段 | 过号和特殊号测试（TC-007至TC-009） | 2小时 | 待分配 |
| 第四阶段 | 综合场景测试（TC-010） | 1小时 | 待分配 |
| 第五阶段 | 回归测试和缺陷修复验证 | 1小时 | 待分配 |

### 3.2 测试优先级

- **P0（高优先级）**：TC-001, TC-002, TC-003, TC-005, TC-006
- **P1（中优先级）**：TC-004, TC-007, TC-008, TC-009
- **P2（低优先级）**：TC-010

---

## 四、测试数据准备脚本

### 4.1 数据库初始化脚本（示例）

```sql
-- 创建测试医生
INSERT INTO doctor (identifier, password, full_name, department_id) 
VALUES ('doctor_test_001', 'password123', '测试医生A', 1);

-- 创建测试排班
INSERT INTO schedule (doctor_id, schedule_date, start_time, end_time, total_slots, booked_slots)
VALUES (1, '2025-12-25', '09:00:00', '12:00:00', 20, 0);

-- 创建测试患者（示例）
INSERT INTO patient (identifier, password, full_name, phone_number, status)
VALUES 
  ('patient_001', 'password123', '测试患者1', '13800138001', 'active'),
  ('patient_002', 'password123', '测试患者2', '13800138002', 'active');
  -- ... 更多患者
```

### 4.2 API测试脚本（Postman/curl示例）

```bash
# 1. 患者登录
curl -X POST http://localhost:8080/api/auth/patient/login \
  -H "Content-Type: application/json" \
  -d '{"identifier":"patient_001","password":"password123"}'

# 2. 创建预约
curl -X POST http://localhost:8080/api/appointments \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer {token}" \
  -d '{"scheduleId":1,"patientId":1}'

# 3. 签到
curl -X POST http://localhost:8080/api/appointments/{appointmentId}/check-in \
  -H "Authorization: Bearer {token}"

# 4. 获取叫号队列
curl -X GET http://localhost:8080/api/appointments/doctor/{doctorId}/call-queue \
  -H "Authorization: Bearer {token}"
```

---

## 五、缺陷记录模板

### 缺陷记录格式

```
【缺陷ID】：BUG-001
【缺陷标题】：过号重排后队列顺序不正确
【严重程度】：高/中/低
【优先级】：P0/P1/P2
【测试用例】：TC-007
【复现步骤】：
1. 患者1正常签到
2. 系统叫号患者1
3. 患者1过号
4. 患者1重新签到
5. 查看队列顺序

【实际结果】：患者1未排在最后
【预期结果】：患者1应排在队列最后
【环境信息】：开发环境，Chrome浏览器
【附件】：截图/日志
```

---

## 六、测试通过标准

### 6.1 功能测试通过标准

- [ ] 所有P0优先级测试用例100%通过
- [ ] 所有P1优先级测试用例≥90%通过
- [ ] 无阻塞性缺陷（P0级别）
- [ ] 严重缺陷（P1级别）≤3个

### 6.2 性能测试通过标准

- [ ] 叫号队列接口响应时间≤500ms
- [ ] 签到接口响应时间≤300ms
- [ ] 支持并发签到（10个用户同时签到）

### 6.3 兼容性测试通过标准

- [ ] 微信小程序正常使用
- [ ] 不同手机型号兼容
- [ ] 不同微信版本兼容

---

## 七、测试报告模板

### 7.1 测试执行总结

```
测试日期：2025-XX-XX
测试人员：XXX
测试环境：开发环境
测试版本：v1.0.0

测试用例统计：
- 总用例数：10
- 执行用例数：10
- 通过用例数：X
- 失败用例数：Y
- 通过率：XX%

缺陷统计：
- 总缺陷数：X
- 已修复：Y
- 待修复：Z
- 严重缺陷：X
```

### 7.2 测试结论

- [ ] 功能完整性：✅/❌
- [ ] 规则正确性：✅/❌
- [ ] 性能表现：✅/❌
- [ ] 建议发布：✅/❌

---

## 八、附录

### 8.1 相关接口文档

- 签到接口：`POST /api/appointments/{appointmentId}/check-in`
- 过号重排接口：`POST /api/appointments/{appointmentId}/recheck-in`
- 叫号队列接口：`GET /api/appointments/doctor/{doctorId}/call-queue`
- 创建预约接口：`POST /api/appointments`

### 8.2 相关代码位置

- 叫号队列逻辑：`AppointmentService.getCallQueue()` 第867行
- 签到逻辑：`AppointmentService.checkIn()` 第683行
- 过号重排逻辑：`AppointmentService.recheckInAfterMissedCall()` 第1044行
- 实时候诊序号分配：`AppointmentService.assignRealTimeQueueNumber()` 第1130行

### 8.3 测试工具

- Postman：API接口测试
- 微信开发者工具：小程序功能测试
- 数据库管理工具：数据准备和验证
- 日志查看工具：问题排查

---

## 九、更新记录

| 版本 | 日期 | 更新内容 | 更新人 |
|------|------|---------|--------|
| v1.0 | 2025-12-24 | 初始版本 | 待填写 |

---

**测试方案制定人**：待填写  
**审核人**：待填写  
**批准人**：待填写




