# 加号功能改进方案

## 问题描述

当前实现存在的问题：
1. **号源开放性问题**：直接增加 `totalSlots`，导致加号号源对所有患者开放
2. **排队问题**：无法区分普通预约和加号预约的排队顺序
3. **号源锁定问题**：无法确保加号患者能获得专属号源

## 改进方案对比

### 方案一：使用特殊时段标识（推荐）

**核心思路**：创建一个特殊的 `TimeSlot` 记录，专门用于加号，避免与普通排班冲突。

#### 实现步骤

1. **创建加号专用时段**
```sql
-- 插入一个特殊的时段，用于标识加号
INSERT INTO time_slots (slot_name, start_time, end_time, slot_type)
VALUES ('加号专用时段', '00:00:00', '23:59:59', 'ADDON');
```

2. **创建虚拟号源时使用特殊时段**
```java
// 获取加号专用时段
TimeSlot addOnTimeSlot = timeSlotRepository.findBySlotType("ADDON")
    .orElseThrow(() -> new RuntimeException("加号专用时段未配置"));

// 创建虚拟号源
Schedule virtualSlot = new Schedule();
virtualSlot.setDoctor(originalSchedule.getDoctor());
virtualSlot.setScheduleDate(originalSchedule.getScheduleDate());
virtualSlot.setSlot(addOnTimeSlot); // 使用特殊时段
virtualSlot.setLocation(originalSchedule.getLocation());
// ... 其他设置
```

**优点**：
- 避免唯一约束冲突
- 加号号源完全独立，不影响普通预约
- 可以精确控制加号患者的访问权限

**缺点**：
- 需要修改 `time_slots` 表结构（增加 `slot_type` 字段）
- 需要初始化特殊时段数据

---

### 方案二：预留机制（当前推荐）

**核心思路**：不创建虚拟号源，而是在预约时检查是否为加号患者，并使用预留字段。

#### 实现步骤

1. **批准时创建预留记录**
```java
// 不修改 totalSlots，而是创建一个预留标记
Schedule schedule = scheduleRepository.findById(application.getScheduleId())
    .orElseThrow(() -> new RuntimeException("排班不存在"));

// 创建加号预约（状态：PENDING_PAYMENT）
Appointment appointment = new Appointment();
appointment.setSchedule(schedule);
appointment.setPatient(patient);
appointment.setAppointmentType(AppointmentType.ADD_ON);
appointment.setStatus(AppointmentStatus.PENDING_PAYMENT);
appointment.setPaymentDeadline(LocalDateTime.now().plusHours(24));
// 关键：不占用 bookedSlots，等支付后再占用
appointmentRepository.save(appointment);
```

2. **预约时检查逻辑**
```java
// 在普通患者预约时，检查可用号源
public boolean isSlotAvailable(Integer scheduleId) {
    Schedule schedule = scheduleRepository.findById(scheduleId).orElseThrow();
    
    // 计算实际可用号源 = totalSlots - bookedSlots - 待支付的加号数量
    Integer pendingAddOnCount = appointmentRepository.countByScheduleAndTypeAndStatus(
        schedule, AppointmentType.ADD_ON, AppointmentStatus.PENDING_PAYMENT);
    
    Integer actualAvailable = schedule.getTotalSlots() 
                            - schedule.getBookedSlots() 
                            - pendingAddOnCount;
    
    return actualAvailable > 0;
}
```

3. **支付成功后占用号源**
```java
// 加号支付成功
appointment.setStatus(AppointmentStatus.scheduled);
schedule.setBookedSlots(schedule.getBookedSlots() + 1);
```

4. **超时释放**
```java
// 超时时只需取消预约，不需要修改 totalSlots
appointment.setStatus(AppointmentStatus.cancelled);
// 不修改 bookedSlots，因为从未占用过
```

**优点**：
- 不需要修改数据库结构
- 逻辑简单清晰
- 加号号源被"软预留"，不影响普通预约的号源计数

**缺点**：
- 需要在多处检查可用号源时考虑待支付的加号
- 查询逻辑稍复杂

---

### 方案三：独立加号号源池

**核心思路**：在 `schedules` 表中增加专门的加号字段。

#### 数据库修改
```sql
ALTER TABLE schedules
ADD COLUMN addon_total_slots INT DEFAULT 0 COMMENT '加号总数',
ADD COLUMN addon_booked_slots INT DEFAULT 0 COMMENT '加号已预约数';
```

#### 实现逻辑
```java
// 批准时增加加号号源
schedule.setAddonTotalSlots(schedule.getAddonTotalSlots() + application.getAddedSlots());

// 创建加号预约
appointment.setAppointmentType(AppointmentType.ADD_ON);

// 支付成功
schedule.setAddonBookedSlots(schedule.getAddonBookedSlots() + 1);

// 超时释放
schedule.setAddonTotalSlots(schedule.getAddonTotalSlots() - 1);
```

**优点**：
- 加号号源完全独立
- 统计清晰
- 不影响普通预约逻辑

**缺点**：
- 需要修改数据库结构
- 增加字段维护成本

---

## 排队问题解决方案

### 方案A：就诊序号区分

```java
// 加号患者使用特殊的序号范围
// 普通预约：1-100
// 加号预约：101-200

Integer nextNumber;
if (appointment.getAppointmentType() == AppointmentType.ADD_ON) {
    // 加号从 101 开始
    Integer maxAddOnNumber = appointmentRepository
        .findMaxAppointmentNumberByScheduleAndType(schedule, AppointmentType.ADD_ON);
    nextNumber = (maxAddOnNumber == null || maxAddOnNumber < 101) ? 101 : maxAddOnNumber + 1;
} else {
    // 普通预约从 1 开始
    Integer maxNormalNumber = appointmentRepository
        .findMaxAppointmentNumberByScheduleAndType(schedule, AppointmentType.NORMAL);
    nextNumber = (maxNormalNumber == null) ? 1 : maxNormalNumber + 1;
}
```

### 方案B：排队优先级

```sql
-- 在 appointments 表增加优先级字段
ALTER TABLE appointments
ADD COLUMN queue_priority INT DEFAULT 0 COMMENT '排队优先级（数字越小越优先）';
```

```java
// 加号患者可以设置更高的优先级
if (appointment.getAppointmentType() == AppointmentType.ADD_ON) {
    // 根据紧急程度设置优先级
    switch (application.getUrgencyLevel()) {
        case CRITICAL: appointment.setQueuePriority(1); break;
        case HIGH: appointment.setQueuePriority(2); break;
        case MEDIUM: appointment.setQueuePriority(3); break;
        case LOW: appointment.setQueuePriority(4); break;
    }
} else {
    appointment.setQueuePriority(5); // 普通预约优先级最低
}

// 叫号时按优先级排序
List<Appointment> queue = appointmentRepository
    .findByScheduleOrderByQueuePriorityAscAppointmentNumberAsc(schedule);
```

---

## 推荐实现方案

综合考虑，推荐使用 **方案二（预留机制）+ 方案A（序号区分）**：

### 核心实现

1. **不修改 totalSlots**，加号预约在支付前不占用号源
2. **使用独立的序号范围**区分普通预约和加号预约
3. **在查询可用号源时**，扣除待支付的加号数量
4. **支付成功后**才真正占用 bookedSlots

### 优势

- ✅ 最小化数据库修改
- ✅ 加号号源被软预留，不会被普通患者抢占
- ✅ 排队顺序清晰可控
- ✅ 逻辑相对简单

### 需要修改的地方

1. **AppointmentRepository**：增加查询方法
2. **ScheduleService**：修改可用号源检查逻辑
3. **AddOnSlotService**：修改序号分配逻辑
4. **前端**：显示时区分普通号和加号

---

## 实施建议

### 短期方案（快速修复）
使用方案二（预留机制），最小化改动，快速上线。

### 长期方案（完善功能）
考虑方案三（独立号源池），提供更清晰的统计和管理能力。

### 过渡方案
先实施短期方案，收集用户反馈后再决定是否升级到长期方案。
